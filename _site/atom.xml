<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>黑妞haha-前端开发</title>
 <link href="http://heiniuhaha.github.com/atom.xml" rel="self"/>
 <link href="http://heiniuhaha.github.com"/>
 <updated>2012-08-28T09:18:16+08:00</updated>
 <id>http://heiniuhaha.github.com</id>
 <author>
   <name>宋建敏</name>
   <email>heiniuhaha@gmail.com</email>
 </author>

 
 <entry>
   <title>seajs模块依赖的加载处理</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/26/seajs-require-theory"/>
   <updated>2012-08-26T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/26/seajs-require-theory</id>
   <content type="html">&lt;p&gt;最近在做项目的时候发现一些关于模块依赖问题，特记录下:&lt;/p&gt;

&lt;p&gt;比如现有3个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*init.js*/
define(function(require, exports, module){
	require(&amp;#39;jquery&amp;#39;);
	require(&amp;#39;jquery.plugA&amp;#39;);
})

/*jquery.plugA.js*/
define(function(require, exports, module){
	require(&amp;#39;jquery&amp;#39;);
	require(&amp;#39;jquery.plugB&amp;#39;);
	//code...
})

/*jquery.plugB.js*/
define(functioin(require, exports, module){
	require(&amp;#39;jquery&amp;#39;);
	//code...
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如执行init.js时，init.js、jquery.plugA.js、jquery.plugB.js都会依赖到jquery，那么这种情况下seajs对jquery如何处理的呢？只执行一次？执行多次？还是其他方式？&lt;/p&gt;

&lt;p&gt;此处参考玉伯的回答：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我对模块调用的理解是，调用是指获取某个模块的接口。在 SeaJS 里，只有 seajs.use, require.async, 和 require 会产生&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;模块调用，比如： &lt;code&gt;var a = require('./a')&lt;/code&gt; 在执行 require(&amp;#8216;./a&amp;#8217;) 时，会获取模块的接口，如果是第一次调用，会初始化模块 a，以后再调用时，直接返回模块 a 的接口 define 只是注册模块信息，比如打包之后： &lt;code&gt;define(id, deps, factory)&lt;/code&gt; 是注册了一个模块到 seajs.cache 中，define 类似： &lt;code&gt;seajs.cache[id] = { id: id, dependencies: deps, factory: factory }&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;是纯注册信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;而 &lt;code&gt;require('./a')&lt;/code&gt; 时，才会执行 &lt;code&gt;seajs.cache['a'].factory&lt;/code&gt;, 执行后得到 &lt;code&gt;seajs.cache['a'].exports&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content>
 </entry>
 
 <entry>
   <title>【转】jQuery 模块介绍与 jQuery 插件的深度模块化</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/15/seajs-jquery-plugin"/>
   <updated>2012-08-15T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/15/seajs-jquery-plugin</id>
   <content type="html">&lt;p&gt;转自玉伯 &lt;a href='http://lifesinger.wordpress.com/2011/08/19/jquery-introduction-and-plugins-modulization/'&gt;jQuery 模块介绍与 jQuery 插件的深度模块化&lt;/a&gt;,方便不能翻墙的同学查看。&lt;/p&gt;

&lt;h2 id='jquery_'&gt;jQuery 模块&lt;/h2&gt;

&lt;p&gt;大名鼎鼎的 jQuery 就不多介绍了，详细介绍推荐官网：jquery.com 阮一峰最近整理的文章也不错，推荐：&lt;a href='http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html'&gt;jQuery 设计思想&lt;/a&gt;, &lt;a href='http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html'&gt;jQuery 最佳实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;几点感悟：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;jQuery 是 DOM 操作类库，其核心功能是找到 DOM 元素并对其进行操作。&lt;/li&gt;

&lt;li&gt;拿 jQuery 与 YUI, Dojo 等框架相比是不公平的，就如拿轮胎和汽车相比一样。jQuery 只是一个轮胎，功能很单一，YUI 和 Dojo 等则是相对完整的汽车，除了轮胎，还有引擎、外壳等等。&lt;/li&gt;

&lt;li&gt;说 jQuery 不适合构建大型应用，就如说轮胎不适合参加赛车比赛一样不合逻辑。你可以用 jQuery 做轮胎，然后选择其他部件组合起来去 DIY 一辆赛车。能否胜出，得看赛车手的 DIY 水准。&lt;/li&gt;

&lt;li&gt;jQuery的困局在于 DIY 高手不多，经常是一个好轮胎挂上一堆破破烂烂的外壳就上前线了。jQuery 的破局也在于 DIY. DIY 意味着灵活、可替换性，意味着可快速前行和高性能。&lt;/li&gt;

&lt;li&gt;jQuery 灵活性带来的缺陷，比如有可能由选择器和链式风格导致的低效 DOM 操作，目前在提供了同类功能的 YUI3 等类库中同样存在。这不是类库的问题，更多是因为使用者的经验欠缺导致的。就如一把优秀的菜刀，到了一个拙劣的厨子手中，依旧切不好菜一样。工具很重要，但更重要的是我们得提升自己的刀工。&lt;/li&gt;

&lt;li&gt;最后，回到第一点：jQuery 是 DOM 操作类库。非 DOM 操作，都是 jQuery 的辅助功能，不是 jQuery 的强项，就如菜刀不能当斧头用一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可以通过简单封装，让 jQuery 成为 CommonJS 的模块。这样，调用时只要 require 即可：&lt;/p&gt;

&lt;p&gt;test.html:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;http://modules.seajs.com/libs/seajs/1.0.1/sea.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
seajs.use(&amp;#39;./init&amp;#39;);
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.js:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;seajs.config({
  alias: {
    &amp;#39;juery&amp;#39;: &amp;#39;jquery/1.6.1/jquery&amp;#39;
  }
});

define(function(require, exports, module) {
  var $ = require(&amp;#39;jquery&amp;#39;);
  // do something with jQuery
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='jquery_'&gt;jQuery 插件的模块化&lt;/h2&gt;

&lt;p&gt;jQuery 提供了 DOM 操作功能，在实际应用中，我们还需要 cookie, template, storage 等等一系列功能。这时可以从 jQuery 社区中寻找各种插件来完成。大部分插件通过 jQuery 插件的模块化 一文中提供的方法封装就好。&lt;/p&gt;

&lt;p&gt;之前的封装方法，总结成一句话是：“jQuery 穿肠过，插件身上留”。正如 Kidwind 反馈的一样，每次“穿肠过”的时候都要运行一次插件代码，频繁调用某些插件时，会存在 CPU 浪费，还可能带来隐患：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;假设有以下jquery插件a, b, c, d，它们之间的关系如下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;b 依赖于 a&lt;/li&gt;

&lt;li&gt;c 依赖于 a&lt;/li&gt;

&lt;li&gt;d 依赖于 b c&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;假设页面使用到d插件，那么插件a将进行两次初始化，也就是会调用两次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;code&gt;var $ = require('jquery');require('a')($);&lt;/code&gt;
&lt;p&gt;进行插件a的注册，当系统复杂时，重复的插件注册会不会影响系统的性能，同时会不会存在隐患？如插件b对引用的插件a进行了部分功能扩展，当引入插件c的时候又重新注册了插件a，那么插件b对插件a的扩展将不存在了，当然改写插件功能的实际情况也许不会存在，此处只是举个例子，说明隐患的存在。 如何避免重复的插件注册，可以避免隐患，同时获得更好的性能（避免了多次插件注册的运算耗时）。&lt;/p&gt;

&lt;p&gt;面对这种情况，我们究竟应该如何做好 jQuery 插件的模块化？&lt;/p&gt;

&lt;p&gt;jQuery 插件的形式&lt;/p&gt;

&lt;p&gt;jQuery 插件一般可以总结为以下模板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function($) {  
  // Main plugin function
  $.fn.PLUGIN = function(options) {
    // snip...
  };

  // Public plugin function
  $.fn.PLUGIN.FUNCT = function() {
    // Cool JS action
  };

  // Default settings for the plugin
  $.fn.PLUGIN.defaults = { /* snip... */ };

  // Private function that is used within the plugin
  // snip...
})(jQuery);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简言之就是往 &lt;code&gt;$.fn&lt;/code&gt; 上添加新成员，有部分插件还会往 &lt;code&gt;$&lt;/code&gt; 上添加成员。&lt;/p&gt;

&lt;p&gt;之前的“穿肠过”模块化方式，可以表示为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function() { return function($) {
  $.fn.PLUGIN = ...
}});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
  var $ = require(&amp;#39;jquery&amp;#39;);
  require(&amp;#39;some-jquery-plugin&amp;#39;)($);

  $(sth).PLUGIN(...);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不是很直观，不够方便，还有前面提到的隐患。&lt;/p&gt;

&lt;p&gt;深度模块化&lt;/p&gt;

&lt;p&gt;为了更好的模块化，意味着我们要添加更多代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {
  var $ = require(&amp;#39;jquery&amp;#39;).sub();

  // Main plugin function
  $.fn.PLUGIN = function(options) {
    // snip...
  };

  // Public plugin function
  $.fn.PLUGIN.FUNCT = function() {
    // Cool JS action
  };

  // Default settings for the plugin
  $.fn.PLUGIN.defaults = { /* snip... */ };

  // Private function that is used within the plugin
  // snip...

  module.exports = $;
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样封装后，调用变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
  var $ = require(&amp;#39;jquery&amp;#39;);
  var PLUGIN = require(&amp;#39;some-jquery-plugin&amp;#39;);
  PLUGIN(sth).PLUGIN(...);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样能解决之前提到的重复初始化问题，但是 &lt;code&gt;PLUGIN(sth).PLUGIN(…)&lt;/code&gt; 的使用方式怪怪的。比如这个非常帅的 chosen 插件，按照上面的方式模块化后，调用方式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chosen(&amp;#39;#some-id&amp;#39;).chosen();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然可用，但怎么看怎么别扭。这是因为 jQuery 是以 DOM 为中心的，代码的默认流程是找到要操作的 DOM 元素，然后对其进行操作。这种代码书写方式，对于模块后的插件来说，很别扭。更好的期待中的调用方式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
  var $ = require(&amp;#39;jquery&amp;#39;);
  var Chosen = require(&amp;#39;chosen&amp;#39;);
 
  var chosen = new Chosen(selector, options);
  chosen.doSth(...);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理论上，我们甚至可以不知道 chosen 依赖 jQuery, 我们需要关心的只是 chosen 的 API. 上面这种理想的调用方式，需要我们对插件进行“深度”模块化：&lt;/p&gt;

&lt;p&gt;some-jquery-plugin.js:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {
  var $ = require(&amp;#39;jquery&amp;#39;);

  // Main plugin function
  function PLUGIN(selector, options) {
    var els = $(selector);
    // snip...
  };

  // Public plugin function
  PLUGIN.FUNCT = function() {
    // Cool JS action
  };

  // Default settings for the plugin
  PLUGIN.defaults = { /* snip... */ };

  // Private function that is used within the plugin
  // snip...

  module.exports = PLUGIN;
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，在 plugin 的代码里，我们并不对 $.fn 或 $ 进行扩展，只用 $ 来进行 DOM 操作而已，返回的是独立的 PLUGIN 对象，就和我们写普通的业务模块一样。这样，就实现预期中更优雅的调用方式。&lt;/p&gt;

&lt;p&gt;jQuery 的插件机制，在模块化面前很鸡肋。jQuery 一直被冠以“不适合大型项目”，也和 jQuery 的这种插件机制有关系。这会导致大家都去污染 $.fn, 这就和污染全局变量一样。项目一大，冲突的概率，和调试的成本都会变大，很悲剧。&lt;/p&gt;

&lt;p&gt;因此，推荐大家利用模块的机制去重构一部分好用的 jQuery 插件，目前 dew 项目里已经重新实现了 cookie 等部分模块。强烈推荐大家都参与进来，将自己喜欢的，常用的 jQuery 等插件迁移过来。或者推进插件作者直接修改源码，增加对 CommonJS 的支持。路漫漫，但众人拾柴火焰高，星火可燎原，期待大家的参与。&lt;/p&gt;

&lt;p&gt;建议大家直接 fork dew 项目，可以将自己重构的模块 pull request 过来，邮件给 seajs(at)googlegroups.com 群组。讨论和 code review 后，就可以转成 dew 的正式模块。&lt;/p&gt;

&lt;p&gt;等模块丰富起来，我们就可以有更多时间去做更意思的事情了。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>seajs实战参考</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/14/seajs-combat"/>
   <updated>2012-08-14T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/14/seajs-combat</id>
   <content type="html">&lt;h2 id='seajs'&gt;seajs实战参考&lt;/h2&gt;

&lt;p&gt;该页面列举了 SeaJS 中的常用实战过程中的问题。只要掌握这些方法，就可以娴熟地开始对你的网站进行模块化开发了。&lt;/p&gt;

&lt;p&gt;默认情况下，SeaJS 要求所有文件都是标准的 CMD 模块，但现实场景下，有大量 jQuery 插件等非 CMD 模块存在。在 SeaJS 里，通过以下方式，可以直接调用非标准模块。&lt;/p&gt;

&lt;h3 id='js'&gt;全站通用的要加载的库只写一次，而不想每个js里都调用，太繁琐&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//可以放在在 init.js 里暴露到全局，这样，所有在 init.js 之后载入的文件，就都可以直接通过全局变量来拿 $ 等对象。

seajs.use(&amp;#39;init&amp;#39;)

//init.js
define(function(require, exports) {
	var $ = jQuery = require(&amp;#39;jquery&amp;#39;);
	
	// 暴露到全局
	window.$ = $;
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='1__jquery'&gt;1. 暴露 jQuery&lt;/h3&gt;

&lt;p&gt;jQuery 插件都依赖 jQuery 模块，为了加载 jQuery 插件，首先得将 jQuery 模块暴露出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 配置 jquery 并放入预加载项中
seajs.config({
  alias: {
    &amp;#39;jquery&amp;#39;: &amp;#39;https://a.alipayobjects.com/static/arale/jquery/1.7.2/jquery.js&amp;#39;
  },
  preload: [&amp;quot;jquery&amp;quot;]
})

// 将 jQuery 暴露到全局
seajs.modify(&amp;#39;jquery&amp;#39;, function(require, exports) {
  window.jQuery = window.$ = exports
})&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='2__jquery_'&gt;2. 修改 jQuery 插件的接口&lt;/h3&gt;

&lt;p&gt;我们以 jquery.cookie 插件为例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 配置别名
seajs.config({
  alias: {
    &amp;#39;cookie&amp;#39;: &amp;#39;https://raw.github.com/carhartl/jquery-cookie/master/jquery.cookie.js&amp;#39;
  }
})

// 将 jQuery Cookie 插件自动包装成 CMD 接口
seajs.modify(&amp;#39;cookie&amp;#39;, function(require, exports, module) {
  module.exports = $.cookie
})&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='3__cookie_'&gt;3. 调用 Cookie 插件&lt;/h3&gt;

&lt;p&gt;这样，在其他模块中，就可以直接调用 cookie 插件了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a.js:

define(function(require, exports) {
  var cookie = require(&amp;#39;cookie&amp;#39;)

  cookie(&amp;#39;the_cookie&amp;#39;)
  cookie(&amp;#39;the_cookie&amp;#39;, &amp;#39;the_value&amp;#39;)

  // ...
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整范例：&lt;a href='http://seajs.org/test/issues/auto-transport/test.html'&gt;http://seajs.org/test/issues/auto-transport/test.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='seajs'&gt;seajs里版本号和时间戳问题&lt;/h2&gt;

&lt;p&gt;用 seajs 组织项目，上线后，经常需要更新特定文件或所有文件的时间戳，以清空浏览器缓存。最简单的方式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//用来维护 jquery 等类库模块的版本号
seajs.config({
  alias: {
    &amp;#39;jquery&amp;#39;: &amp;#39;jquery/1.6.2/jquery&amp;#39;,
    &amp;#39;backbone&amp;#39;: &amp;#39;backbone/0.5.1/backbone&amp;#39;,
    &amp;#39;a&amp;#39;: &amp;#39;a.js?20110801&amp;#39;,
    &amp;#39;b&amp;#39;: &amp;#39;b.js?20110801&amp;#39;
  }
});	

//利用 map,批量更新时间戳是最方便的
seajs.config({
  &amp;#39;map&amp;#39;: [
    [ /^(.*\.(?:css|js))(.*)$/i, &amp;#39;$1?20110801&amp;#39; ]
  ]
});	&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id22'&gt;条件加载&lt;/h2&gt;

&lt;p&gt;第一种：把依赖的模块都在 define 头部手工声明，不再依赖 SeaJS 的自动解析功能。这个模块同时依赖 play 和 work 两个模块，加载器会把这两个模块文件都下载下来。如果需要在 require 模块之后串行执行代码，那么只能用这个方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&amp;#39;play&amp;#39;, &amp;#39;work&amp;#39;], function(require, exports) {
	 //是出去玩，还是工作？
    var choice = require(condition() ? &amp;#39;play&amp;#39; : &amp;#39;work&amp;#39;);
	//选择的难度
    console.log(choice.hard());
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种：使用 require.async 来进行条件加载，从静态分析的角度来看，require.async适合需要执行动态加载的模块很大（比如大量 json 数据），不适合都下载下来。但是require.async 方式加载的模块，不能打包工具找到，自然也不能被打包进上线的 js 中；而前一种方式可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
    require.async(condition() ? &amp;#39;play&amp;#39; : &amp;#39;work&amp;#39;, function(choice) {
        console.log(choice.hard());
    });
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id23'&gt;按需加载&lt;/h2&gt;

&lt;p&gt;很多时候模块并不需要立即加载，等到需要时再加载，性能更好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//init.js
$(&amp;quot;#J_PicCover&amp;quot;).click(function(){
	require.async(&amp;#39;module/highlight&amp;#39;, function(){
		$(&amp;quot;.buy-info&amp;quot;).highlight({color:&amp;#39;#ffe5c4&amp;#39;,speed:500,complete:function(){
		},iterator:&amp;#39;sinusoidal&amp;#39;});
	});
});

//highlight.js
define(function(require, exports) {
	jQuery.fn.highlight = function(settings) {
		//…...
	}
});&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>seajs快速参考</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/13/seajs-cheet-sheet"/>
   <updated>2012-08-13T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/13/seajs-cheet-sheet</id>
   <content type="html">&lt;h2 id='seajs'&gt;seajs快速参考&lt;/h2&gt;

&lt;p&gt;该页面列举了 SeaJS 中的常用 API。只要掌握这些方法，就可以娴熟地进行模块化开发。&lt;/p&gt;

&lt;h3 id='id15'&gt;启动模块系统&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;http://modules.seajs.org/seajs/1.2.0/sea.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  	seajs.use(&amp;#39;./main&amp;#39;);
	seajs.use([&amp;#39;./a&amp;#39;, &amp;#39;./b&amp;#39;], function(a, b) {
	  a.init();
	  b.init();
	});	  
&amp;lt;/script&amp;gt;

//callback 参数是可选的。当只启动加载一个模块，且不需要 callback 时，可以用 data-main 属性来简化：
&amp;lt;script src=&amp;quot;http://modules.seajs.org/seajs/1.2.0/sea.js&amp;quot; data-main=&amp;quot;./main&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

/*
引入 sea.js 时，可以把 sea.js 与其他文件打包在一起，提前打包好，或利用 combo 服务动态打包。
无论哪一种方式，为了让 sea.js 内部能快速获取到自身路径，推荐手动加上 id 属性：
加上 seajsnode 值，可以让 sea.js 直接获取到自身路径，而不需要通过其他机制去自动获取。
这对性能和稳定性会有一定提升，推荐默认都加上。
*/
&amp;lt;script src=&amp;quot;path/to/sea.js&amp;quot; id=&amp;quot;seajsnode&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='seajsconfig'&gt;seajs.config&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//seajs.config 可以叠加，可以在多处调用，同名 key 覆盖，不同名的 key 叠加。这样可以做到：区域配置可以覆盖通用配置或可以说在区域配置中可对 seajs config 再做按需配置而不会影响到通用配置。
seajs.config({

  //alias最常用来做版本配置与管理，也可以用来做命名空间管理。
  alias: {
    &amp;#39;es5-safe&amp;#39;: &amp;#39;es5-safe/0.9.2/es5-safe&amp;#39;,
    &amp;#39;json&amp;#39;: &amp;#39;json/1.0.1/json&amp;#39;,
    &amp;#39;jquery&amp;#39;: &amp;#39;jquery/1.7.2/jquery&amp;#39;
  },
  
  /*
  使用 preload 配置项，可以在普通模块加载前，提前加载并初始化好指定模块。
  注意：preload 中的配置，需要等到 use 时才加载。
  preload 配置不能放在模块文件里面
  */
  preload: [
    Function.prototype.bind ? &amp;#39;&amp;#39; : &amp;#39;es5-safe&amp;#39;,
    this.JSON ? &amp;#39;&amp;#39; : &amp;#39;json&amp;#39;
  ],
  
  //值为 true 时，加载器会使用 console.log 输出所有错误和调试信息。 默认为 false, 只输出关键信息
  debug: true,
  
  //该配置可将某个文件映射到另一个。可用于在线调试，非常方便。
  map: [
    [&amp;#39;http://example.com/js/app/&amp;#39;, &amp;#39;http://localhost/js/app/&amp;#39;]
  ],
  
  /*
  SeaJS 在解析顶级标识时，会相对 base 路径来解析。
  注意：一般请不要配置 base 路径，保持默认往往最好最方便。
  base 路径的默认值，与 sea.js 的访问路径相关：
  如果 sea.js 的访问路径是：
    http://example.com/js/libs/sea.js
  则 默认base 路径为：
    http://example.com/js/libs/	 
  */ 
  base: &amp;#39;http://example.com/path/to/base/&amp;#39;,
  
  //获取模块文件时，&amp;lt;script&amp;gt; 或 &amp;lt;link&amp;gt; 标签的 charset 属性。 默认是 utf-8 。
  charset: &amp;#39;utf-8&amp;#39;	  
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='seajsuse'&gt;seajs.use&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
模块加载器
seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里。在模块代码里需要异步加载其他模块时，可以使用 require.async 方法。
*/

seajs.use(&amp;#39;./a&amp;#39;);

seajs.use(&amp;#39;./a&amp;#39;, function(a) {
  a.doSomething();
});

seajs.use([&amp;#39;./a&amp;#39;, &amp;#39;./b&amp;#39;], function(a, b) {
  a.doSomething();
  b.doSomething();
});

//seajs.use 与 dom ready 事件没有任何关系。
//如果某些操作要确保在 dom ready 后执行，需要自己使用 jquery 等类库来保证
seajs.use([&amp;#39;jquery&amp;#39;, &amp;#39;page&amp;#39;], function($, page) {
  $(function() {
    page.init()
  })
})	&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='define'&gt;define&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
CMD 模块定义 define(factory);
define 是全局函数，用来定义模块。
在开发时，define 仅接收一个 factory 参数。
factory 可以是一个函数，也可以是对象、字符串等类型。
factory 为对象、字符串等非函数类型时，表示模块的接口就是该对象、字符串等值。
factory 为函数时，表示模块的构造方法。执行该方法，可以得到模块向外提供的接口。
*/
define(function(require, exports, module) {

  // The module code goes here

});

/*
模块代码需要用 define 回调包起来：id 与 dependencies 参数是可以省略的
id 用来显式指定模块 ID。当你的项目上线，所有的模块都合并到了一个文件中，如果不显示指定， SeaJS 就无从知道哪个模块是哪个了。在开发的时候，一般用不到它。
dependencies 也是如此。它列出了当前模块所依赖的模块，在开发的时候是不需要写明的。 SeaJS 会检查你的模块回调函数，找到所有的 require 语句，从而得到你的模块的所有依赖。 在真正 require 当前模块时，会先去请求这个模块的依赖，加载完毕，再去初始化当前的模块。
*/
define(id, dependencies, function(require, exports, module) {
    // module code.
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='require'&gt;require&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
require 是一个方法，用来获取其他模块提供的接口。
require 接受 模块标识 作为唯一参数

模块依赖解析，靠的是三个重要的规则：
	不能重命名 require
	不能覆盖 require
	require 的参数必须是字符串字面量，不可以 require(foo()) 或者 require(bar)， 也不可以是 require(should_be_a ? &amp;#39;a&amp;#39; : &amp;#39;b&amp;#39;)。	参数值必须是字符串直接量,如 require(&amp;quot;my-module&amp;quot;);
	核心原因是因为在浏览器端，文件的读取是异步的，依赖信息要提前获取，不能在运行时才确定。在服务器端，文件读取是同步的，因此可以是变量。
*/
define(function(require) {
  var a = require(&amp;#39;./a&amp;#39;);
  a.doSomething();
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='requireasync'&gt;require.async&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
require.async(id, callback)
async 方法可用来异步加载模块，并在加载完成后执行指定回调。
*/
define(function(require, exports, module) {
  // load one module
  require.async(&amp;#39;./b&amp;#39;, function(b) {
    b.doSomething();
  });

  // load multiple modules
  require.async([&amp;#39;./c&amp;#39;, &amp;#39;./d&amp;#39;], function(c, d) {
    // do something
  });
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='requireresolve'&gt;require.resolve&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
require.resolve(id)
使用模块系统内部的路径解析机制来解析并返回模块路径。该函数不会加载模块，只返回解析后的绝对路径。
*/
define(function(require, exports) {
  console.log(require.resolve(&amp;#39;./b&amp;#39;)); 
  // ==&amp;gt; &amp;#39;http://example.com/js/b.js&amp;#39;
});	&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='exports'&gt;exports&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
exports 是一个对象，用来向外提供模块接口。
exports 仅仅是 module.exports 的一个引用。
在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。
因此给 exports 赋值是无效的，不能用来更改模块接口，正确的写法是用 return 或者给 module.exports 赋值。
exports = {}是错误的，module.exports ={}才是正确的写法。
*/

define(function(require, exports) {
  // snip...
  exports.foo = &amp;#39;bar&amp;#39;;
  exports.doSomething = function() {};
});
module.exports

define(function(require, exports, module) {
  // snip...
  module.exports = {
    name: &amp;#39;a&amp;#39;,
    doSomething: function() {};
  };
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='module'&gt;module&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。
*/
define(function(require, exports, module) {

	//module.id 模块标识。require(module.id) 必然返回此模块的 exports 。
   console.log(require(module.id) === exports); // true
   
   //module.uri根据模块系统的路径解析规则得到的模块绝对路径。
   console.log(module.uri); // http://example.com/path/to/this/file.js
   
   //module.dependencies dependencies 是一个数组，表示当前模块的依赖列表。
   
   /*
   module.exports 当前模块对外提供的接口。
   module.exports 的赋值需要同步执行，不能放在回调函数里
   */
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上接口是最常用的，要牢记于心。&lt;/p&gt;

&lt;h3 id='id16'&gt;可写成如下&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;seajs.config({
  alias: {
    &amp;#39;jquery&amp;#39;: &amp;#39;http://modules.seajs.org/jquery/1.7.2/jquery.js&amp;#39;
  }
});

define(&amp;#39;hi&amp;#39;, function(require, exports) {
    exports.sayHi = function() {
        alert(&amp;#39;hi&amp;#39;)
    } 
})

seajs.use([&amp;#39;jquery&amp;#39;, &amp;#39;hi&amp;#39;], function($, h) {
    $(&amp;#39;#beautiful-sea&amp;#39;).click(h.sayHi)
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='js'&gt;模块化后的js写法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) = {
 
    //原jquery.js代码...
 
    module.exports = $.noConflict(true);
});
 
//init.js
define(function(require, exports, module) = {
    var $ = require(&amp;#39;jquery&amp;#39;);
    var m1 = require(&amp;#39;module1&amp;#39;);
     
    exports.initPage = function() {
        $(&amp;#39;.content&amp;#39;).html(m1.run());    
    }
});
 
//module1.js
define(function(require, exports, module) = {
    var $ = require(&amp;#39;jquery&amp;#39;);
    var m2 = require(&amp;#39;module2&amp;#39;);
    var m3 = require(&amp;#39;module3&amp;#39;);
     
    exports.run = function() {
        return $.merge([&amp;#39;module1&amp;#39;], $.merge(m2.run(), m3.run()));    
    }
});
 
//module2.js
define(function(require, exports, module) = {
    exports.run = function() {
        return [&amp;#39;module2&amp;#39;];
    }
});
 
//module3.js
define(function(require, exports, module) = {
    var $ = require(&amp;#39;jquery&amp;#39;);
    var m4 = require(&amp;#39;module4&amp;#39;);
     
    exports.run = function() {
        return $.merge([&amp;#39;module3&amp;#39;], m4.run());    
    }
});
 
//module4.js
define(function(require, exports, module) = {
    exports.run = function() {
        return [&amp;#39;module4&amp;#39;];
    }
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id17'&gt;实际使用中&lt;/h2&gt;

&lt;p&gt;在工程内使用seajs，以前引用的插件、模块也都要用define的语法重新进行封装，比较麻烦，老代码可以不修改，继续使用就好。但强烈建立花点时间都修改成 CMD 模块，这样对以后的维护，以及页面性能很有好处。不然以后修改起来估计会更麻烦。&lt;/p&gt;

&lt;p&gt;其实可以混用的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;underscore.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;backbone.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script src=&amp;quot;sea.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，常用的 jquery 等类库，依旧是传统的用法，用全局变量引用就好，通过同步引入的方式，也不会有依赖顺序问题。 自己的代码，都按照 CMD 规范写成模块的形式。&lt;/p&gt;

&lt;p&gt;其实上面的方式挺好的，特别对于要兼容老代码的情况的。 推荐还是都彻底模块化，看起来要多写一些 require，但值得，因为这样可以让每个模块自身的信息完整，从而减少对 环境的依赖，对后续的可维护性很好益处。&lt;/p&gt;

&lt;h2 id='seajsapi'&gt;seajs官方api&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://seajs.org/docs/#api'&gt;详细官方文档&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/240'&gt;模块系统&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/242'&gt;CMD 模块定义规范&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/258'&gt;模块标识&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/259'&gt;require 书写约定&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/260'&gt;模块加载器&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/262'&gt;配置&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/265'&gt;常用插件&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/281'&gt;打包部署&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/266'&gt;快速参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='id18'&gt;第三方库&lt;/h2&gt;

&lt;p&gt;SeaJS 提供了一个类似于npm的管理工具，里面有他们改造好的第三方库，你可以在这里找找是否有适合的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;spm Git Pero: &lt;a href='https://github.com/seajs/spm'&gt;https://github.com/seajs/spm&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;spm module list: &lt;a href='http://seajs.cloudfoundry.com/'&gt;http://seajs.cloudfoundry.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='seajs_blog_'&gt;seajs blog 等文档&lt;/h2&gt;

&lt;h3 id='id19'&gt;初级入门&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://www.cnblogs.com/leoo2sk/archive/2011/06/27/write-javascript-with-seajs.html'&gt;使用 SeaJS 实现模块化 JavaScript 开发&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://clonn.blogspot.com/2011/05/seajs-nonblocking-require-library.html'&gt;SeaJS, 模組化開發加載套件&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.infoq.com/cn/news/2011/05/nodeparty-hangzhou'&gt;NodeParty 杭州站会议纪实：Jscex, SeaJS 与 MyFOX&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/14/seajs-and-nodejs/'&gt;SeaJS – 跨环境模块化开发实践 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://ghsky.com/2011/05/seajs-first-view.html'&gt;初识 SeaJS&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/04/26/intro-to-seajs/'&gt;SeaJS – 不仅仅是脚本加载器 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.infoq.com/cn/presentations/hjp-infoq-salon'&gt;去哪儿网的 JavaScript 模块化之路&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/04/05/seajs-080-released/'&gt;海纳百川、有容乃大 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id20'&gt;中级使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://cyj.me/why-seajs/zh/'&gt;seajs所为何-逸才&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/08/10/extending-built-in-native-objects/'&gt;扩展原生对象与 es5-safe 模块 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/08/01/best-practice-of-version-management/'&gt;SeaJS 里版本号和时间戳管理的最佳实践&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/07/24/online-local-debug/'&gt;在线本地调试大观 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.cnblogs.com/leoo2sk/archive/2011/07/01/temod-intro.html'&gt;在 SeaJS 中实现 html 模板文件的加载（Temod 介绍）&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://blog.163.com/jinlu_hz/blog/static/113830152201142011225195/'&gt;在 SeaJS 里使用 LABjs&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/26/exports-and-module-load-in-seajs/'&gt;SeaJS 中的 exports 和模块加载 -玉伯&lt;/a&gt;-墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/18/jquery-plugins-modulization/'&gt;jQuery 插件的模块化 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/02/seajs-css-support/'&gt;SeaJS – 对 CSS 模块的支持 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/286'&gt;直接调用 jQuery 插件等非标准模块的方法&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/08/19/jquery-introduction-and-plugins-modulization/'&gt;jQuery 模块介绍与 jQuery 插件的深度模块化 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.heiniuhaha.com/file/sea-zh.js'&gt;seajs中文版源码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id21'&gt;高级探索&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://hax.iteye.com/blog/1146699'&gt;shim是应该抛异常还是应该fail silently？-hax&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://limu.iteye.com/blog/1136712'&gt;扩展 SeaJS 模块定义中的 module 参数的应用示例 -李牧&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/17/the-difference-between-seajs-and-requirejs/'&gt;SeaJS 和 RequireJS 的异同 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>使用github+jekyll搭建blog环境，完美替代wordpress</title>
   <link href="http://heiniuhaha.github.com/lessons/2012/08/09/use-jekyll-build-blog"/>
   <updated>2012-08-09T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2012/08/09/use-jekyll-build-blog</id>
   <content type="html">&lt;p&gt;也来讲讲怎么使用github pages做blog环境&lt;/p&gt;

&lt;h2 id='id8'&gt;优点&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;空间免费，github托管，稳定又安全，遭遇过空间商跑路的朋友是不是想起伤心往事；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;允许本地服务器调试，脱离网络写文章毫无压力，因为可以使用git命令同步来管理文章，版本控制妥妥的，对技术人员来说，一键恢复，实在是神物；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;还能绑定顶级域名，亲，人家免费空间竟然还允许我们绑域名有木有~~；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;文章用markedown编写，以前遭受排版困扰的亲们是不是很激动；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id='id9'&gt;购买域名&lt;/h2&gt;

&lt;p&gt;可以去&lt;a href='http://www.net.cn'&gt;万网&lt;/a&gt;，这两天正好在促销. &lt;img alt='net-cn-sales' src='/assets/themes/twitter/pic/net-cn-sales.png' /&gt;&lt;/p&gt;

&lt;h2 id='dnspod'&gt;用免费的dnsPod做域名解析&lt;/h2&gt;

&lt;p&gt;dnspod链接地址&lt;a href='https://www.dnspod.cn/'&gt;https://www.dnspod.cn/&lt;/a&gt; &lt;img alt='dnspod settings' src='/assets/themes/twitter/pic/dnspod-setting.png' /&gt;&lt;/p&gt;

&lt;h2 id='githubjekyll'&gt;github注册和本地电脑jekyll等环境配置&lt;/h2&gt;

&lt;p&gt;参考最底下的参考文章，省略。。。&lt;/p&gt;

&lt;h2 id='id10'&gt;命令&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;h3 id='git'&gt;git命令获取远程文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='id11'&gt;定位到目录&lt;code&gt;heiniu.github.com&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd .ssh/heiniuhaha.github.com&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='id12'&gt;使用&lt;code&gt;rake&lt;/code&gt;命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;rake page           # Create a new page.
rake post           # Begin a new post in ./_posts
rake preview        # Launch preview environment&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='markdown'&gt;写文章的时候学习下&lt;a href='https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md'&gt;markdown语法&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;如:中文单引号 &amp;#96; 用来标注小块代码,如&lt;code&gt;github&lt;/code&gt; &lt;code&gt;jekyll&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='git'&gt;最后提交git代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git add .
git commit . -m &amp;#39;just another commit&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='id13'&gt;日常发布完整命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git//本地如果无远程代码，先做这步，不然就忽略
cd .ssh/heiniuhaha.github.com//定位到你blog的目录下
git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件
git status //查看本地自己修改了多少文件
git add .//添加远程不存在的git文件
git commit * -m &amp;quot;what I want told to someone&amp;quot;
git push origin master //更新到远程服务器上&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id14'&gt;参考文章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html'&gt;搭建一个免费的，无限流量的Blog&amp;#8212;-github Pages和Jekyll入门&lt;/a&gt; 阮一峰写于2012-08-25 【推荐】&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://beiyuu.com/github-pages/'&gt;使用Github Pages建独立博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://blog.leezhong.com/tech/2010/08/25/make-github-as-blog-engine.html'&gt;使用github作为博客引擎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://jekyllbootstrap.com/'&gt;The Quickest Way to Blog with Jekyll.&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='git_api_'&gt;附件：git api 总结图&lt;/h2&gt;

&lt;p&gt;链接：&lt;a href='/assets/themes/twitter/pic/git-api.png'&gt;http://www.heiniuhaha.com/assets/themes/twitter/pic/git-api.png&lt;/a&gt; &lt;img alt='git api 总结图' src='/assets/themes/twitter/pic/git-api.png' /&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Use Google Code Prettify</title>
   <link href="http://heiniuhaha.github.com/lessons/2012/08/09/use-google-code-prettify"/>
   <updated>2012-08-09T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2012/08/09/use-google-code-prettify</id>
   <content type="html">&lt;h2 id='jekyll_googlecodeprettify'&gt;jekyll中代码高亮 google-code-prettify&lt;/h2&gt;

&lt;p&gt;看了jekyll的代码高亮插件pygments,觉得配置太复杂,就用了轻量级的google-code-prettify,使用非常方便.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先下载用于高亮代码的文件包,点击&lt;a href='http://code.google.com/p/google-code-prettify/downloads/list'&gt;google-code-prettify下载地址&lt;/a&gt;下载small版本的代码.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;复制进相应的目录,找到default.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Users/heiniu/.ssh/heiniuhaha.github.com/_includes/themes/default.html&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;打开default.html,在最后面添加相应的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/code/prettify.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/jquery-1.8.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  $(function(){
    $(&amp;quot;pre&amp;quot;).addClass(&amp;quot;prettyprint linenums&amp;quot;);
    prettyPrint();
    $(&amp;#39;.entry a&amp;#39;).each(function(){
      if($(this).attr(&amp;quot;href&amp;quot;).indexOf(&amp;quot;heiniuhaha&amp;quot;) == -1){
        $(this).attr(&amp;quot;target&amp;quot;, &amp;quot;_blank&amp;quot;);
      }
    })
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>My Github First Blog</title>
   <link href="http://heiniuhaha.github.com/lessons/2012/08/07/my-github-first-blog"/>
   <updated>2012-08-07T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2012/08/07/my-github-first-blog</id>
   <content type="html">&lt;h2 id='themes'&gt;应用themes发现的问题&lt;/h2&gt;

&lt;p&gt;我尝试了the-program的theme,但是出现一个使用iframe的警告,看了源文件,没有发现可修复的地方,直接放弃这个theme吧.&lt;/p&gt;

&lt;p&gt;&lt;img alt='theme iframe waring' src='/assets/themes/twitter/img/theme-iframe.png' /&gt;&lt;/p&gt;

&lt;h4 id='code'&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;For security reasons,framing is not allowed.
	
&amp;lt;iframe src=&amp;quot;http://markdotto.github.com/github-buttons/github-btn.html?user=plusjade&amp;amp;repo=jekyll-bootstrap&amp;amp;type=fork&amp;amp;count=true&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我只能换成twitter皮肤,我想这个皮肤应该是最稳定的了.等使用熟练后再改成自己的皮肤.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>jQuery1.4.3核心源码解读</title>
   <link href="http://heiniuhaha.github.com/jquery/2012/07/30/jquery-1.4.3-core-source"/>
   <updated>2012-07-30T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/jquery/2012/07/30/jquery-1.4.3-core-source</id>
   <content type="html">&lt;h3 id='jquery'&gt;构造jquery.&lt;/h3&gt;

&lt;p&gt;相对于其它库里传统的构造对象方法. jquery提供了一种截然不同的方法. 它选择创造一个全新的奇异世界.&lt;/p&gt;

&lt;p&gt;首先所有的jquery代码被一个自动执行的闭包包裹起来, 只在后面暴露$和jQuery这2个变量给外界 尽量避开变量冲突.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(window,  undefined){  
…..  
})(window)  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;window和undefined都是为了减少变量查找所经过的scope. 当window通过传递给闭包内部之后, 在闭包内部使用它的时候, 可以把它当成一个局部变量, 显然比原先在window scope下查找的时候要快一些. undefined也是同样的道理, 其实这个undefined并不是javascript数据类型六君子之一的undefined, 而是一个普普通通的变量名. 只是因为没给它传递值. 它的值就是undefined. undefined并不是javascript的保留字.&lt;/p&gt;

&lt;p&gt;然后是一个套子套住jquery的构造方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jQuery = (function(){   --------------------jq1  
    var jQuery = function( selector, context ){    ---------------jq2  
        ……..  
};  
    return (window.jQuery = window.$ = jQuery);  
})()  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先定义jq1, 这个jQuery最终在&lt;code&gt;return  (window.jQuery = window.$ = jQuery)&lt;/code&gt;的时候会变成 window下面的变量供外界使用. 而jq2供jquery内部执行的时候调用. 最终作为jq1的引用返回. &lt;code&gt;return (window.jQuery = window.$ = jQuery);&lt;/code&gt;这句话等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.jQuery = window.$ = jQuery;  
return window. jQuery.  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在来看看jquery对象是怎么被创建出来的. jquery作为一个独立特行的库, 它产生jquery对象时并不需要用new 操作符.. 它宁愿选择这种方式, 比如要产生一个构造函数Man的对象.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Man(name){  
    this.name = name;     
}  
  
function People(name){  
    return new Man(name);  
}  
  
var pe = People(&amp;quot;zengtan&amp;quot;);  
alert (pe.name);  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样真正作为jQuery对象的构造方法的并不是 function (selector, context){ } 而是&lt;code&gt;jQuery.fn.init. &lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jQuery  =  function( selector, context ) {            
        return new jQuery.fn.init( selector, context );  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery.fn就是jQuery.prototype. 见源码102行. &lt;code&gt;jQuery.fn = jQuery.prototype = {} &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;init是挂在jQuery.prototype上的属性. 当&lt;code&gt;jQuery(‘div’)&lt;/code&gt;的时候, 实际上转交给了&lt;code&gt;jQuery.fn.init&lt;/code&gt;构造函数来生成对象. 当然我们想用new jQuery来生成jquery对象也可以. 跟直接用jQuery()没区别. 因为构造函数一定会返回一个对象.如果显示指定了返回某个对象.就会返回那个对象, 否则才会返回this对象. 好比说, 有只母鸡被你强迫下一个蛋, 它会先看窝里有没有别人的蛋, 如果没有,才会自己努力下一个. 这里显然返回的是jQuery.fn.init的对象.&lt;/p&gt;

&lt;p&gt;也许现在你开始回忆制作jquery插件时, 明明是给jQuery.prototype添加方法. 这里返回的又是jQuery.prototype.init的对象. 原来在源码333行, jQuery.prototype.init.prototype = jQuery. prototype; 现在很容易看明白. 给jQuery.prototype添加方法就等于给jQuery. prototype.init.prototype添加方法了. JQuery api里的方法大部分都是通过jQuery.prototype扩展上去的, 除此之外. 我们还要给jquery对象加上索引. 给集合添加length属性,让他们更像一个数组里的元素.&lt;/p&gt;

&lt;p&gt;搞明白这些, 再来看jQuery. prototype.init这个方法里究竟是怎样生产jquery对象的. 我们可以把jQuery. prototype.init想象成一个火腿肠加工器. 只要你放了正确的原料进去, 它就可以把原料变成火腿肠生产出来.如果你不小心放错了原料.它也会帮你变成火腿肠. 不过只有塑料包装, 里面没有火腿. 当然这个加工器里面的构造是很复杂的, 它需要判断材料种类, 数量等等. 一般这个材料主要为这4种情况 1 dom节点 2 字符串 3 函数 4 数组 5 其他元素&lt;/p&gt;

&lt;p&gt;一 jQuery构造方法 jQuery的构造方法会生成一组jquery对象的集合.具体关于init方法的分析, 还是留在选择器部分说吧.&lt;/p&gt;

&lt;h3 id='jquery'&gt;jQuery对象访问&lt;/h3&gt;

&lt;p&gt;jquery构造完对象之后, 会提供一些方法访问这些对象.&lt;/p&gt;

&lt;p&gt;1 jQuery.prototype.size&lt;br /&gt;集合内元素的数量 就是通过this.length得到.&lt;/p&gt;

&lt;p&gt;2 jQuery.prototype.get&lt;br /&gt;按照索引取得集合内某个元素, 返回包装前的原始对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get: function( num ) {  
        return num == null ?   
 //如果参数为null或者undefiend. 注意是==.  
            this.toArray() :  //如果不传参数, 集合内的元素全部转化为一个数组(1)  
            ( num &amp;lt; 0 ? this.slice(num)[ 0 ] : this[ num ] );   
//调用silce方法截取某一个.可以传入负数并且返回的是包装前的对象.  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) 看看这里的this.toArray函数.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;toArray: function() {  
        return slice.call( this, 0 );  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单, 就是让当前jquery对象冒充Array的对象, 调用Array.prototype.slice进行截断. 返回的是一个数组. 至于为什么可以像这样使用对象冒充. 我们抽个地方来好好讨论一下. 其实如果查看v8之类开源引擎的源码就知道(当然也可以在ecma里挣扎一番). 要调用Array原型链上的方法. 通常这个对象满足2个条件就可以了. 1, 本身可以存取属性. 2, length属性不能是只读(可以没有length属性). 由于Array.prototype.slice方法太长了. 我拿Array.prototype.push方法举例. 在V8的src目录下的array.js可以找到这些方法. 比如push&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function ArrayPush() {  
  var n = ToUint32(this.length);  
 /* 
    对象/数组本身的length. 如果为null或者undefined, 会在ToUint32中转化为0. 所以 
    即使没有length属性,也会给一个默认的0值. 
 */  
  var m = %_ArgumentsLength();    //参数的length.  
  for (var i = 0; i &amp;lt; m; i++) {  
    this[i+n] = %_Arguments(i);   //复制属性  
  }  
  this.length = n + m;            //重设length.  
  return this.length;  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到push操作的核心就是复制属性和重设长度. jquery对象完全可以满足这2个条件. 同样的道理 一个对象字面量{}也可以. 而string类型的不可以, 因为不能在string上存取属性. function对象虽然可以存取属性, 也有length属性. 不过它的length属性比较特殊, 表示形参的个数, 是一个只读属性, 源码中的this.length = n + m这一句不起作用, 所以function对象也不行. 同理window对象也不行. 上面的slice.call也是这个原理, 虽然slice方法的实现更复杂一点.&lt;/p&gt;

&lt;p&gt;明白了这个,我们可以解释很多奇怪的问题.比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = {};  
a[0] = 1;  
a[1] = 2;  
Array.prototype.push(a, 3);  
alert (a.length)   // a没有length属性, 默认的给0值, 所以结果为1 .  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在push操作之前添加一句 a.length = 2; 再进行push操作后, a.length就为3了.&lt;/p&gt;

&lt;p&gt;3 jQuery.prototype.index&lt;br /&gt;搜索匹配的元素，并返回相应元素的索引值，从0开始计数。 如果不给 .index() 方法传递参数，那么返回值就是这个jQuery对象集合中第一个元素相对于其同辈元素的位置。 如果参数是一组DOM元素或者jQuery对象，那么返回值就是传递的元素相对于原先集合的位置。 如果参数是一个选择器，那么返回值就是原先元素相对于选择器匹配元素中的位置。如果找不到匹配的元素，则返回-1。 没有什么特别需要解释的, 直接看代码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index: function( elem ) {  
        if ( !elem || typeof elem === &amp;quot;string&amp;quot; ) {     
        //如果没有参数, 或者参数是选择器.  
            return jQuery.inArray( this[0],  
                elem ? jQuery( elem ) : this.parent().children() );  
        //如果有参数(选择器), 则查找元素本身在这些选择器组成的jq对象集合中的位置  
        //如果没有参数, 查找元素本身在它的兄弟节点之间的位置. this.parent().children()可以取得自己和全部兄弟节点.  
}  
        return jQuery.inArray(  
            //参数是一个对象  
            elem.jquery ? elem[0] : elem, this );  
            //如果是jquery对象, 取得它的原始节点. 再查找在当前集合中的位置     
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顾名思义jQuery.inArray就是判断数组里有没有某个元素.当然这里的数组也包括伪数组. 这个方法虽然实现起来很简单, 关于inArray这个名字在jquery的官方论坛却有颇多争议. 很多人认为它应该返回true或者false, 而不是索引的位置. john resig只是说暂时还不准备修改这个方法.&lt;/p&gt;

&lt;p&gt;有些浏览器还不支持Array.prototype.indexOf方法. 所以首先在源码的851行, 有这样一段代码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( Array.prototype.indexOf ) {  
    jQuery.inArray = function( elem, array ) {  
        return indexOf.call( array, elem );  
    };  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果支持Array.prototype.indexOf. 则重写jQuery.inArray, 直接用Array.prototype.indexOf.call(array, elem ); 在页面加载的时候就重写这个方法. 也避免了在函数里反复判断造成的浪费. 然后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inArray: function( elem, array ) {  
        if ( array.indexOf ) {  
//确认indexOf方法存在.或防止indexOf方法被改写.  
            return array.indexOf( elem );  
        }  
        for ( var i = 0, length = array.length; i &amp;lt; length; i++ ) {  
            //否则遍历数组, 返回正确的索引.  
if ( array[ i ] === elem ) {  
                return i;  
            }  
        }  
        return -1;  //如果数组里没有这个元素, 返回-1.  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id4'&gt;数据缓存&lt;/h3&gt;

&lt;p&gt;jQuery.data&lt;/p&gt;

&lt;p&gt;在实际应用中, 我们经常需要往节点中缓存一些数据. 这些数据往往和dom元素紧密相关. dom节点也是对象, 所以我们可以直接扩展dom节点的属性. 不过肆意污染dom节点是不良少年的行为. 我们需要一种低耦合的方式让dom和缓存数据能够联系起来.&lt;/p&gt;

&lt;p&gt;jquery提供了一套非常巧妙的缓存办法.&lt;/p&gt;

&lt;p&gt;我们先在jquery内部创建一个cache对象{}, 来保存缓存数据.&lt;/p&gt;

&lt;p&gt;然后往需要进行缓存的dom节点上扩展一个值为&lt;code&gt;jQuery.expando&lt;/code&gt;的属性, 这里是&lt;code&gt;&quot;jquery&quot; + (new Date).getTime(). &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接着把每个节点的&lt;code&gt;dom[jQuery.expando]&lt;/code&gt;的值都设为一个自增的变量id,保持全局唯一性. 这个id的值就作为cache的key用来关联dom节点和数据. 也就是说cache&lt;span&gt;id&lt;/span&gt;就取到了这个节点上的所有缓存.&lt;/p&gt;

&lt;p&gt;而每个元素的所有缓存都被放到了一个map里面,这样可以同时缓存多个数据.&lt;/p&gt;

&lt;p&gt;比如有2个节点dom1和dom2, 它们的缓存数据在cache中的格式应该是这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cache = {  
    dom1[  jQuery.expando ]: {  
        key1: value1,  
        key2: value2  
},  
dom2[ jQuery.expando ] {  
    key3: value3,  
    key4: value4  
}  
}  &lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;jQuery.expando&lt;/code&gt;
&lt;p&gt;我们在看源码之前, 先根据上面的原理来自己实现一个简单的缓存系统.以便增强理解.&lt;/p&gt;

&lt;p&gt;先把跟data相关的所有代码都封装到一个闭包里,通过返回的接口暴露给外界. 同时为了简便,我们拆分成setData和getData两个方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;ddd&amp;quot;&amp;gt;dddddddd&amp;lt;/div&amp;gt;  
  
&amp;lt;script&amp;gt;  
  
var Data = function(){  
    var cache = {};  
    var expando = &amp;quot;zengtan&amp;quot; + +new Date;  
    var uuid = 1;  
      
    var setData = function(elem, key, value){  
            var id = elem[expando];  
            if (!id){   //第一次给元素设置缓存  
                id = ++uuid;  
                elem[expando] = id;  
            }  
            if (!cache[id]){   //这个元素第一次进行缓存或者缓存已被清空  
                cache[id] = {};  
            }  
            cache[id][key] = value;  
    };  
  
    var getData = function(elem, key){  
        var id = elem[expando];  //取得cache里跟dom节点关联的key  
        return cache[id] &amp;amp;&amp;amp; cache[id][key] || null;  //如果缓存里没有, 返回null  
    }  
  
    return {  
        setData: setData,  
        getData: getData      
    }  
}()  
  
&amp;lt;/script&amp;gt;  
  
var div = document.getElementById(&amp;quot;ddd&amp;quot;);  
Data.setData(div, &amp;quot;name&amp;quot;, &amp;quot;zengtan&amp;quot;);  
var value = Data.getData(div, &amp;quot;name&amp;quot;);  
alert (value)  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看源码实现.&lt;/p&gt;

&lt;p&gt;首先声明一些特殊的节点, 在它们身上存属性的时候可能会抛出异常.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;noData: {  
        &amp;quot;embed&amp;quot;: true,  
        // Ban all objects except for Flash (which handle expandos)  
        &amp;quot;object&amp;quot;: &amp;quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&amp;quot;,  
        &amp;quot;applet&amp;quot;: true  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个对象里的数据用在acceptData方法中, 跟1.42版本相比, 这里多了对什么flash的object的特殊处理. 总之acceptData方法就是判断节点能否添加缓存.&lt;/p&gt;

&lt;p&gt;看具体的jQuery.data&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data: function( elem, name, data ) {  
    if ( !jQuery.acceptData( elem ) ) {  
        return;  
    }  
    //noData类型  
    elem = elem == window ?  
        windowData :  
        elem;  
    //处理elem是window的情况, 如果不单独处理的话, 等于增加了一个全局变量, windowData也是一个{}  
    var isNode = elem.nodeType,  
    //判断是不是dom节点,由于非dom节点的缓存在继承和内存泄露上都会造成麻烦,1.43版本已经把dom节点和其他对象分开处理了.  
        id = isNode ? elem[ jQuery.expando ] : null,  
        cache = jQuery.cache, thisCache;  
    //因为存数据的时候, 会给elem[ jQuery.expando ]设置一个全局唯一标志量. 判断id是否为undefined, 就知道已经有没有往这个元素上缓存过数据.   
  
    if ( isNode &amp;amp;&amp;amp; !id &amp;amp;&amp;amp; typeof name === &amp;quot;string&amp;quot; &amp;amp;&amp;amp; data === undefined ) {  
    //如果是dom节点对象, 并且现在是get方式(typeof name === &amp;quot;string&amp;quot; &amp;amp;&amp;amp; data === undefined表示get方式), 又没有缓存(!id表示没有缓存).  
        return;  
    }  
  
    if ( !isNode ) {  
        cache = elem;  
    //如果是非dom节点对象, 取缓存里的属性就直接取元素本身属性.  
    } else if ( !id ) {  
        elem[ jQuery.expando ] = id = ++jQuery.uuid;  
    //第一次进行缓存, 分配一个全局唯一标志id.  
    }  
  
    if ( typeof name === &amp;quot;object&amp;quot; ) {  
    //如果key是对象类型  
        if ( isNode ) {  
            cache[ id ] = jQuery.extend(cache[ id ], name);  
    /* 
    把整个对象都复制到原来的缓存上, 比如 
         $(&amp;#39;#ddd&amp;#39;).data({ 
                &amp;quot;v2&amp;quot;: &amp;quot;bbb&amp;quot;, 
                &amp;quot;v3&amp;quot;: &amp;quot;ccc&amp;quot; 
            }); 
            相当于$(&amp;#39;#ddd&amp;#39;).data(&amp;quot;v2&amp;quot;, &amp;quot;bbb&amp;quot;).data(&amp;quot;v3&amp;quot;:&amp;quot;ccc&amp;quot;); 
            1.42版本用的cache[ id ] = jQuery.extend(true, {}, name). 这样会清空以前的缓存. 
        */  
        } else {  
            jQuery.extend( cache, name );  
        //如果不是dom节点. 把属性复制到元素本身.  
        }  
  
    } else if ( isNode &amp;amp;&amp;amp; !cache[ id ] ) {  
        //如果cache[ id ]中没有东西, 表示这个元素第一次进行缓存或者缓存已被清空, 设置cache[ id ]为一个新的map.  
        cache[ id ] = {};  
    }  
  
    thisCache = isNode ? cache[ id ] : cache;  
  
    if ( data !== undefined ) {  
        /* 
            set操作, 也可以防止一些意外的情况下缓存被清空. 比如data未定义的情况下, 缓存操作是无效的. 
            var a = {}; 
            var b; 
            $(a).data(&amp;quot;c&amp;quot;, 3); 
            $(a).data(&amp;quot;c&amp;quot;, b); b为undefined. 这句是无效的. 要移除缓存可以用removeData方法. 
        */  
        thisCache[ name ] = data;  
        //即cache[ id ][ name ] = data, 把data设置进cache缓存对象中, 前面分配的自增id当做key来关联  
    }  
  
    return typeof name === &amp;quot;string&amp;quot; ? thisCache[ name ] : thisCache;  
    //如果key是string类型, 返回key对应的缓存, 否则返回整个元素上的缓存  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从新版本的源码里可以看到, 1.42版本中data方法的几个缺点已经被解决了.&lt;/p&gt;

&lt;p&gt;当然我们用jquery缓存系统的时候, 一般调用的是prototype方法, prototype方法除了调用上面的静态方法之外. 还加入了对节点上自定义事件的处理, 留在event部分再讲.&lt;/p&gt;

&lt;p&gt;当然, 我们还需要删除缓存的方法. 现在看看removeData的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Jquery.removeData  
  
    removeData: function( elem, name ) {  
        if ( !jQuery.acceptData( elem ) ) {  
            return;  
        }  
  
        elem = elem == window ?  
            windowData :  
            elem;  
  
        var isNode = elem.nodeType,  
            id = isNode ? elem[ jQuery.expando ] : elem,  
            //id是该元素在cache上面的key, 如果不是节点就返回元素本身.  
            cache = jQuery.cache,  
            thisCache = isNode ? cache[ id ] : id;  
  
        if ( name ) {  
            if ( thisCache ) {  
                delete thisCache[ name ];  
                //删除key对应的缓存数据  
                if ( isNode &amp;amp;&amp;amp; jQuery.isEmptyObject(thisCache) ){  
                    //如果元素是dom节点并且缓存为一个空对象.说明所有缓存的数据都已经被删掉了.  
                    //那么重新调用一次removeData方法, 删掉缓存系统里已经无用的东西, 防止内存泄露, 注意现在走的是下面else分支.   
                    jQuery.removeData( elem );   
                }  
            }  
        } else {  
            if ( isNode &amp;amp;&amp;amp; jQuery.support.deleteExpando ) {  
                //如果支持delete, 见特性检测部分.  
                delete elem[ jQuery.expando ];  
                //删掉元素的jQuery.expando属性  
  
            } else if ( elem.removeAttribute ) {  
                //如果支持removeAttribute  
                elem.removeAttribute( jQuery.expando );  
  
            } else if ( isNode ) {  
                delete cache[ id ];  
                //如果是dom节点, 全局缓存里删除以这个id为key的对象.  
            } else {  
                for ( var n in elem ) {  
                    //如果是其它对象, 删除对象的所有属性. 防止内存泄露.  
                    delete elem[ n ];  
                }  
            }  
        }  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id5'&gt;队列控制&lt;/h3&gt;

&lt;p&gt;队列控制也是jquery中很有特点的一个功能. 可以用来管理动画或者事件等的执行顺序. queue和dequeue主要为动画服务. 比如在jquery的动画里, 因为javascript的单线程异步机制, 如果要管理一批动画的执行顺序, 而不是让它们一起在屏幕上飞舞. 一般我们是一个一个的把下个动画写在上个动画的回调函数中, 意味着如果要让十个动画按次序执行. 至少要写9个回调函数. 好吧我承认我做过这样的事, 直接导致我的视力从5.2变为5.1.&lt;/p&gt;

&lt;p&gt;现在有了队列机制, 可以把动画都放到队列中依次执行.究竟怎样把动画填充进队列.用的是queue方法. 不过queue非常先进的是.把动画push进队列之后,还会自动去执行队列里的第一个函数. 队列机制里面的另外一个重要方法是dequeue, 意为取出队列的第一个函数并执行.此时队列里面的函数个数变为N-1.&lt;/p&gt;

&lt;p&gt;看个例子.比如我要让2个div以动画效果交替隐藏和显示.同时只能有一个div在进行动画.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;   
#div1 {background:#aaa;width:188px;height:188px;position:absolute;top:10px;left: 110px;}  
#div2 {background:#aaa;width:188px;height:188px;position:absolute;top:310px;left: 110px;}  
&amp;lt;/style&amp;gt;  
  
&amp;lt;body&amp;gt;   
&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;我是一个div&amp;lt;/div&amp;gt;  
&amp;lt;div id=&amp;quot;div2&amp;quot;&amp;gt;我是另一个div&amp;lt;/div&amp;gt;  
&amp;lt;/body&amp;gt;  
  
//用queue可以这样做.  
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;  
$(document).queue([  
    function(fn){  
        $(&amp;quot;#div1&amp;quot;).hide(1000, fn);   
      //fn === $(document).dequeue;  
    },  
    function(fn){  
        $(&amp;quot;#div2&amp;quot;).hide(1000, fn);  
    },  
    function(fn){  
        $(&amp;quot;#div1&amp;quot;).show(1000, fn);  
    },  
    function(fn){  
        $(&amp;quot;#div2&amp;quot;).show(1000, fn);  
    }  
])  
&amp;lt;/script&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们需要一个载体, 来保存这个队列, 这里选择了document. 其实选什么节点都一样, 保存队列其实也是一个jQuery.data操作. 然后queue的参数是一个数组. 里面的函数就是队列依次执行的函数. 前面讲到, queue方法会自动把队列里的第一个函数取出来执行. 意味着这些代码写完后, div1已经开始渐渐隐藏了. 隐藏完毕后, 如果要让后面的动画继续执行, 还要用$(document).dequeue()继续取出并执行现在队列里的第一个函数. 当然这个操作是放在第一个动画的回调函数里, 以此类推, 第二个.dequeue()要放在第二个动画的回调函数里. 我们看到这里没有用$(document).dequeue(). 因为这句代码太长. 注意队列函数里有一个参数fn, fn是dequeue方法内部传给此函数的, 就是$(document).dequeue().&lt;/p&gt;

&lt;p&gt;在看源码之前, 先自己来想想这个功能应该怎么实现. 首先我们需要一个数组, 里面存放那些动画. 然后需要2个方法, set和get.可以存取动画. 可能我们还需要一个变量来模拟线程锁, 保证队列里的函数不会同时被执行. 最后我们要把这个数组存入dom的缓存中, 方便随时存取和删除.&lt;/p&gt;

&lt;p&gt;看源码, 先是prototype方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.prototype.queue = function( type, data ) {  
        if ( typeof type !== &amp;quot;string&amp;quot; ) {  
            data = type;  
            type = &amp;quot;fx&amp;quot;;    
//修正type, 默认为表示jquery动画的fx, 如果不为&amp;quot;fx&amp;quot;, 即为自己的自定义动画, 一般我们用&amp;quot;fx&amp;quot;就足够了.  
        }  
        if ( data === undefined ) {   
            return jQuery.queue( this[0], type );    
//get队列. 不论集合中是单个或者多个元素, 总是返回第一个元素的队列  
        }  
        return this.each(function( i, elem ) {    
//set队列, 遍历集合内所有元素  
            var queue = jQuery.queue( this, type, data );    
//set并返回队列  
            if ( type === &amp;quot;fx&amp;quot; &amp;amp;&amp;amp; queue[0] !== &amp;quot;inprogress&amp;quot; ) {  
         //防止在执行函数的时候, 这里又进行dequeue操作, 这样会同时执行2个函数, 队列就不受控制了.  
                jQuery.dequeue( this, type );      
//如果队列没有被锁住, 即此时没有在执行dequeue. 移出队列里第一个函数并执行它.  
//毕竟queue的主要任务是添加队列, 执行函数的操作上, 只能当二等公民.  
            }  
        });  
    }  
看看jQuery.queue这个静态方法.  
    jQuery.queue = function( elem, type, data ) {  
        if ( !elem ) {  
            return;  
        }  
        type = (type || &amp;quot;fx&amp;quot;) + &amp;quot;queue&amp;quot;;  
        var q = jQuery.data( elem, type );  
        //取得元素缓存上面的队列  
        if ( !data ) {    
        //如果当data为空, 只是查询queue. 那么返回队列或者[]  
return q || [];  
        }  
        if ( !q || jQuery.isArray(data) ) {  
            q = jQuery.data( elem, type, jQuery.makeArray(data) );   
        /*否则是set操作，注意!q || jQuery.isArray(data)这句代码的含义,   
		如果q为null, 说明缓存上没有队列. 此时哪怕队列里只有一个函数, 也把它转成数组, 保证队列是数组形式  
        如果q不为null, 说明缓存上已经存在队列, 但是如果现在被添加的函数是一个数组的话, 以现在的数组来代替原来的队列, 即把原来的队列清空了.  
        clearQueue函数就是用的这一句代码执行清空队列操作. 
        */    
} else {  
            q.push( data );  
        //缓存上有队列并且只添加一个函数  
        }  
        return q;  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再看dequeue, dequeue的原型方法什么也没做, 直接把参数交给jQuery.dequeue来处理.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dequeue: function( elem, type ) {  
    type = type || &amp;quot;fx&amp;quot;;  
    var queue = jQuery.queue( elem, type ), fn = queue.shift();  
    //取得队列, 和队列里的第一个元素, 这里直接给shift掉了, 先斩后奏.  
    if ( fn === &amp;quot;inprogress&amp;quot; ) {  
        //如果fn===” inprogress”, 说明杀错了人, 我要找的是函数  
        fn = queue.shift();  
        //继续找下一个, 下一个肯定是函数了.  
        }  
        if ( fn ) {  
            if ( type === &amp;quot;fx&amp;quot; ) {  
                queue.unshift(&amp;quot;inprogress&amp;quot;);  
        //函数执行前, 在queue数组的最前面添加一个进程锁, 复活刚才杀错的人.   
		 	  }  
  
            fn.call(elem, function() {  
        //执行函数, 参数就是前面的fn  
                jQuery.dequeue(elem, type);  
            });  
        }  
	}  
})  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“inprogress”进程锁是这样工作的： 如果是dequeue操作, 去掉锁, 执行队列里的函数, 同时给队列加上锁. 如果是queue操作, 要看锁的状态, 如果被锁上了, 就只执行队列的添加操作. 不再调用dequeue. 其实dequeue和queue都可以执行队列里的第一个函数.queue操作添加完队列之后, 会调用dequeue方法去执行函数. 但是用dequeue执行函数的时候, 这时候如果又用queue触发dequeue的话, 很可能同时有2个函数在执行. 队列就失去一大半意义了(还是可以保证顺序, 但是2个动画会同时执行). 不过这个锁只能保证在dequeue的时候, 不被queue操作意外的破坏队列. 如果人为的同时用2个dequeue, 还是会破坏动画效果的. 所以要把fn写在回调函数里.&lt;/p&gt;

&lt;p&gt;清空队列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clearQueue: function( type ) {  
    return this.queue( type || &amp;quot;fx&amp;quot;, [] );  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理上面已经提到过了, 就是这一句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( !q || jQuery.isArray(data) ) {  
    q = jQuery.data( elem, type, jQuery.makeArray(data) );   
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用一个空数组代替了原来的队列.&lt;/p&gt;

&lt;h3 id='id6'&gt;多库共存&lt;/h3&gt;
&lt;code&gt;jQuery.noConflict&lt;/code&gt;
&lt;p&gt;将变量$的控制权让渡给上一个实现它的那个库. 可能很多人都被多库共存时的$变量问题困扰过. 比如你先引入了prototype库,然后又引入了jquery.因为jquery的$会覆盖prototype的$. 现在想调用prototype的$怎么办呢, noConflict方法就派上用场了. Jquery代码里最开始就有一句&lt;code&gt;_$ = window.$ &lt;/code&gt;, 在加载的时候就用&lt;code&gt;_$&lt;/code&gt;来引用原来的&lt;code&gt;$&lt;/code&gt; (比如现在就是prototype库里的$).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend({     
    noConflict: function( deep ) {  
        window.$ = _$;     
//window.$归还给原来的库. 要回归jquery再用window.$ = jQuery就可以了.  
        if ( deep ) {      
            window.jQuery = _jQuery;     
//如果deep为true, jQuery这个变量也可以归还, 不过一般不需要也不推荐这么做.  
        }  
        return jQuery;  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id7'&gt;继承和拷贝&lt;/h4&gt;

&lt;p&gt;jQuery.prototype.extend和jQuery.extend 扩展 jQuery 元素集来提供新的方法, 或者把一个对象的属性拷贝到另外一个对象上. 通常javascript的继承实现有4种方式. 1 构造继承 2 prototype继承 3 属性拷贝 4 实例继承(这个有点特殊, 主要用于继承内置对象)&lt;/p&gt;

&lt;p&gt;这4种继承都有各自的优点和缺陷. 构造继承查找属性快.但无法继承原型链上的方法,而且每次都要为属性复制一份新的副本进行储存 原型继承在性能方面好一些,可以共享原型链.但查找属性慢,因为可能要遍历N条原型链才能找到某个属性.而且原型链太多,会使得结构越加混乱.并且会丢失对象的constructor属性 (对象的constructor总是指向原型链最上层的构造器) 属性拷贝非常灵活,但明显效率偏低. 而且仅仅只是模拟继承. 实例继承主要用来继承Array, Date等内置对象, 用的较少.&lt;/p&gt;

&lt;p&gt;jquery里采用的是属性拷贝.其实用哪种继承是个见仁见智的问题. 也有其它一些库就是用的原型继承.&lt;/p&gt;

&lt;p&gt;前面也可以注意到, jquery只在构造方法或者原型链上定义了少量的核心方法. 其它功能块都是通过extend函数拷贝上去.按需定制. 好比开发商交给我们房子的时候, 只安装了水电暖气等基本设施.电视机洗衣机显然是自己去买比较好.&lt;/p&gt;

&lt;p&gt;属性拷贝原理就是遍历第二个对象, 然后分别把键和值填入第一个对象中.类似于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var i in obj2){  
    Obj1[i] = obj2[i]  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不幸的是jquery里面的做法复杂的多,不仅可以把多个参数的属性都复制到一个对象中,还能实现深度继承. 深度继承是指如果被继承对象和继承对象都有同名属性a, 而且这个属性的值分别是一个对象b和c.会把b和c的属性都合并到一个新的对象里, 作为值返回给合并后的对象. 说的有点复杂, 看个例子.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend( true,          
     { name: “John”, location: { city: “Boston” } },         
     { last: “Resig”, location: { state: “MA” } }         
 );          
  //结果为         
   {   
	  name: “John”, last: “Resig”,          
    location: { city: “Boston”, state: “MA” }   
   }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery的做法主要是这样, 先修正参数,根据第一个参数是boolean还是object确定target是哪个对象. 如果有且只有一个object类型的参数, 则把这个参数里的属性copy到jQuery或者jQuery.prototype上, 扩展jQuery对象.用这个办法可以很方便的编写插件. 否则依次遍历第一个object参数之后的所有object类型对象的属性. 根据是否深度继承用不同的方式进行copy操作. extend会改变第一个参数的引用. 如果不想改变它,可以稍微变通一下,把所有的参数属性都拷贝到一个空对象上.如$.extend({}, obj1, obj2);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend = jQuery.fn.extend = function() {  
    var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy, copyIsArray;  
    //target应该指向被拷贝的对象, deep表示深度拷贝或者浅度拷贝, 如果为true,即深度拷贝.反之为浅度拷贝.  
  
    if ( typeof target === &amp;quot;boolean&amp;quot; ) {  
    //如果显示声明了是深度拷贝还是浅度拷贝  
        deep = target;  
    //重新设置deep  
        target = arguments[1] || {};  
    //修正target, 让它指向第二个参数  
        i = 2;  
    //修正循环开始的位置, copy的时候跳过deep和target, 指向第一个copy对象.  
    }  
  
    if ( typeof target !== &amp;quot;object&amp;quot; &amp;amp;&amp;amp; !jQuery.isFunction(target) ) {  
        //修正target. 确保target是一个可以迭代属性的对象, 从这句代码看出target可以为函数对象  
        target = {};  
    }  
    if ( length === i ) {  
        target = this;  
        --i;  
        /* 
            当只有一个参数是对象的情况(可能前面还有一个true或false).  
            把属性赋值给jquery或者jquery.fn. 帮jquery实现继承. 
            并且重新修正循环起始位置. 
        */  
    }  
  
    for ( ; i &amp;lt; length; i++ ) {  
        if ( (options = arguments[ i ]) != null ) {  
            //只遍历不为null的参数  
            for ( name in options ) {  //遍历copy对象的属性  
                src = target[ name ];    //记录target的属性值  
                copy = options[ name ];  //记录将要被copy进去的值  
                if ( target === copy ) { //防止死循环???  
                    continue;  
                }  
  
                if ( deep &amp;amp;&amp;amp; copy &amp;amp;&amp;amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {  
                    //如果是深度继承并且copy是对象字面量或者数组, 但必须保证至少为对象字面量和数组之一才会继续下面.  
                    //copyIsArray = jQuery.isArray(copy)返回的是boolean.  
                    //如果jQuery.isPlainObject(copy)和jQuery.isArray(copy)都是false,那整个if语句里的判断条件都返回false,  
                    //也就不会执行下面了的深度继承了.比起1.42版本, 很多地方功能没变, 代码还是明显清晰了很多.  
                    if ( copyIsArray ) {   //如果是数组  
                        copyIsArray = false; //重设copyIsArray  
                        clone = src &amp;amp;&amp;amp; jQuery.isArray(src) ? src : [];  
                    //防止深度copy的时候, target为undefined. 此时target应该为对象类型.   
                    //如果target本来为undefined, 要设一个不含属性的默认值, 且类型要跟copy对象保持一致.  
                    } else {  
                        clone = src &amp;amp;&amp;amp; jQuery.isPlainObject(src) ? src : {};  
                    //同上  
                    }  
                    target[ name ] = jQuery.extend( deep, clone, copy );  
                    //深度继承递归调用extend方法进行合并  
                } else if ( copy !== undefined ) {  
                    target[ name ] = copy;  
                    //浅度继承直接复制属性, 但是不要带入undefined值.  
                }  
            }  
        }  
    }  
  
    return target;  
    //返回合并后的对象. 第一个obj参数的引用已经被改变了.  
}  &lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>前端技术牛人列表</title>
   <link href="http://heiniuhaha.github.com/f2e/2012/07/30/f2e-master"/>
   <updated>2012-07-30T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/f2e/2012/07/30/f2e-master</id>
   <content type="html">&lt;h2 id='id2'&gt;牛人列表&lt;/h2&gt;

&lt;p&gt;该页面列举了我仰慕的前端牛人，以他们为榜样，站在巨人的肩膀上学习，能让我们再前端开发道路上更顺利。也推荐给大家学习的目标。会持续更新&amp;#8230;&lt;/p&gt;

&lt;h3 id='id3'&gt;前端架构&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href='http://hikejun.com/blog/'&gt;张克军-kejun&lt;/a&gt;&lt;/strong&gt; 绝对大牛级别的人物，目前在豆瓣负责前端架构，经常出现在各种技术交流活动中，如咱熟知的D2&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href='http://lifesinger.wordpress.com/'&gt;玉伯-岁月如歌&lt;/a&gt;&lt;/strong&gt; 如今火热的Web 浏览器端的模块加载器seajs的开发者，目前在支付宝，研究型+实战型牛人，经常出现在各种技术交流活动中，如咱熟知的D2，乐于布道。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Http Protocol</title>
   <link href="http://heiniuhaha.github.com/2012/07/29/http-protocol"/>
   <updated>2012-07-29T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/2012/07/29/http-protocol</id>
   <content type="html">&lt;p&gt;此文正在进行中。。。&lt;/p&gt;

&lt;h3 id='id1'&gt;参考文章：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html'&gt;互联网协议入门（一）-阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html'&gt;互联网协议入门（二）-阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>ruby更新版本</title>
   <link href="http://heiniuhaha.github.com/ruby/2012/07/20/ruby-update"/>
   <updated>2012-07-20T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/ruby/2012/07/20/ruby-update</id>
   <content type="html">&lt;p&gt;经常有人问： 怎么把mac默认的ruby版本切换到刚安装的新版本？&lt;/p&gt;

&lt;p&gt;答案很简单，用rvm吧&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rvm官方地址 &lt;a href='https://rvm.io/'&gt;https://rvm.io/&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;ruby更新实用详细教程 &lt;a href='http://ruby-china.org/wiki/rvm-guide'&gt;http://ruby-china.org/wiki/rvm-guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常用命令如下：&lt;/p&gt;

&lt;p&gt;安装rvm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -L https://get.rvm.io | bash -s stable --ruby&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将系统重置为最新版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source ~/.bashrc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看系统里的ruby版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;which -a ruby&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有ruby版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm list known&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用一个ruby版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm use 1.8.7&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非常简单，即使是mac新人，使用此命令进行版本控制也无任何压力啊。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Jekyll Introduction</title>
   <link href="http://heiniuhaha.github.com/lessons/2011/12/29/jekyll-introduction"/>
   <updated>2011-12-29T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2011/12/29/jekyll-introduction</id>
   <content type="html">&lt;p&gt;This Jekyll introduction will outline specifically what Jekyll is and why you would want to use it. Directly following the intro we&amp;#8217;ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id='overview'&gt;Overview&lt;/h2&gt;

&lt;h3 id='what_is_jekyll'&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &amp;#8220;a simple, blog aware, static site generator&amp;#8221;.&lt;/p&gt;

&lt;h3 id='examples'&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href='https://github.com/mojombo/jekyll/wiki/Sites'&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id='what_does_jekyll_do'&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system. Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files, compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder. The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id='jekyll_is_not_blogging_software'&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements. This is a common source of confusion when getting started. Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id='why_should_i_care'&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient. The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server. Traditional dynamic blogs like Wordpress require a database and server-side code. Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;

&lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;

&lt;li&gt;No internet connection required.&lt;/li&gt;

&lt;li&gt;Ability to publish via git.&lt;/li&gt;

&lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;

&lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;

&lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id='how_jekyll_works'&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples. This information is not intended to specifically teach you how to do anything, rather it is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id='initial_setup'&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href='/index.html#start-now'&gt;installing jekyll&lt;/a&gt; you&amp;#8217;ll need to format your website directory in a way jekyll expects. Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id='the_jekyll_application_base_format'&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 20011-10-25-open-source-is-good.markdown
|   |-- 20011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br /&gt;Stores configuration data.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br /&gt;This folder is for partial views.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt; &lt;br /&gt;This folder is for the main templates your content will be inserted into. You can have different layouts for different pages or page sections.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br /&gt;This folder contains your dynamic content/posts. the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br /&gt;This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br /&gt;This folder is not part of the standard jekyll structure. The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory. Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href='https://github.com/mojombo/jekyll/wiki/Usage'&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id='jekyll_configuration'&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here: &lt;a href='https://github.com/mojombo/jekyll/wiki/Configuration'&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='content_in_jekyll'&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page. These content &amp;#8220;objects&amp;#8221; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id='posts_and_pages'&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax. Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id='working_with_posts'&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt; &lt;br /&gt;Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory. If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file. Additionally, each file must have &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;YAML Front-Matter&lt;/a&gt; prepended to its content. YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br /&gt;Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy. Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; &lt;br /&gt;Posts can have tags associated with them as part of their meta-data. Tags may be placed on posts by providing them in the post&amp;#8217;s YAML front matter. You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt; &lt;br /&gt;Posts may be categorized by providing one or more categories in the YAML front matter. Categories offer more significance over tags in that they can be reflected in the URL path to the given post. Note categories in Jekyll work in a specific way. If you define more than one category you are defining a category hierarchy &amp;#8220;set&amp;#8221;. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy &amp;#8220;lessons/beginner&amp;#8221;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll. You won&amp;#8217;t find &amp;#8220;lessons&amp;#8221; and &amp;#8220;beginner&amp;#8221; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id='working_with_pages'&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br /&gt;Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;In order to register as a Jekyll page the file must contain &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;YAML Front-Matter&lt;/a&gt;. Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br /&gt;Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br /&gt;If pages are defined in sub-directories, the path to the page will be reflected in the url. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br /&gt;You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br /&gt;Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br /&gt;Generating a sitemap is good practice for SEO.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br /&gt;A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='templates_in_jekyll'&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page&amp;#8217;s or post&amp;#8217;s content. All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;. The site variable holds all accessible content and metadata relative to the site. The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br /&gt;Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;Templates should be coded in HTML and contain YAML Front Matter. All templates can contain Liquid code to work with your site&amp;#8217;s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br /&gt;There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;. The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined. Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id='subtemplates'&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they define another &amp;#8220;root&amp;#8221; layout/template within their YAML Front Matter. This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id='includes'&gt;Includes&lt;/h3&gt;

&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder. Includes are NOT templates, rather they are just code snippets that get included into templates. In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id='using_liquid_for_templating'&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll. This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id='what_is_liquid'&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href='https://github.com/Shopify/liquid'&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href='http://shopify.com'&gt;Shopify&lt;/a&gt;. Liquid is designed for end-users to be able to execute logic within template files without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with your site and post/page data.&lt;/p&gt;

&lt;h3 id='why_do_we_have_to_use_liquid'&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href='http://pages.github.com/'&gt;GitHub Pages&lt;/a&gt;. GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id='liquid_is_not_programmerfriendly'&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code. The point being you can&amp;#8217;t do jackshit in liquid that hasn&amp;#8217;t been allowed explicitly by the implementation. What&amp;#8217;s more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll&amp;#8217;s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins. Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt; &lt;br /&gt;My personal stance is to not invest time trying to hack liquid. It&amp;#8217;s really unnecessary &lt;em&gt;from a programmer&amp;#8217;s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code) you are better off sticking with ruby. Toward that end I&amp;#8217;ve built &lt;a href='http://github.com/plusjade/mustache-with-jekyll'&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='static_assets'&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages. That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2 id='how_jekyll_parses_files'&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt; &lt;br /&gt;This is done with textile or markdown.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt; &lt;br /&gt;This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br /&gt;All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt; &lt;br /&gt;These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax. Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt; &lt;br /&gt;Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id='formatting_files_for_parsing'&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We&amp;#8217;ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;. Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty. This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block. The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here: &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='defining_layouts_for_posts_and_templates_parsing'&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into. If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt; That is to say loading a post file into a template file that refers to another template file with work in the way you&amp;#8217;d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id='how_jekyll_generates_the_final_static_files'&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll&amp;#8217;s job is to generate a static representation of your website. The following is an outline of how that&amp;#8217;s done:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt; &lt;br /&gt;Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt; &lt;br /&gt;Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata. At this stage your site is one big computed ruby object.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br /&gt;Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s). Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &amp;#8220;liquified&amp;#8221;. &lt;br /&gt;&lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt; &lt;br /&gt;Finally the liquid templates are &amp;#8220;rendered&amp;#8221;, thereby processing any liquid syntax provided in the templates and saving the final, static representation of the file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br /&gt;Because Jekyll computes the entire site in one fell swoop, each template is given access to a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you&amp;#8217;ll iterate through and format using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;

&lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap. You can also read the original documentation here: &lt;a href='https://github.com/mojombo/jekyll/wiki/Template-Data'&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='conclusion'&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does. As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id='next_steps'&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at &lt;a href='' /&gt; or jump right into &lt;a href=''&gt;Usage&lt;/a&gt; if you&amp;#8217;d like.&lt;/p&gt;</content>
 </entry>
 
 
</feed>