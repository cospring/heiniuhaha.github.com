<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>黑妞haha-前端开发</title>
 <link href="http://heiniuhaha.github.com/atom.xml" rel="self"/>
 <link href="http://heiniuhaha.github.com"/>
 <updated>2012-11-07T13:13:01+08:00</updated>
 <id>http://heiniuhaha.github.com</id>
 <author>
   <name>宋建敏</name>
   <email>heiniuhaha@gmail.com</email>
 </author>

 
 <entry>
   <title>MOLO前端规范</title>
   <link href="http://heiniuhaha.github.com/f2e/2012/11/07/molo-f2e-standard"/>
   <updated>2012-11-07T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/f2e/2012/11/07/molo-f2e-standard</id>
   <content type="html">&lt;h3 id='molo'&gt;molo前端规范&lt;/h3&gt;

&lt;h4 id='id3951'&gt;一、命名规范：&lt;/h4&gt;

&lt;p&gt;- 公共组件因高度重用，命名从简，不要加前缀&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;各页面class和id采用驼峰命名法，有JS关联的dom对象采用“J_SubjectPagin”此格式书写，防止页面改版等更新需求时误删js钩子。&lt;/li&gt;

&lt;li&gt;频道下的页面命名清晰，不怕命名长，怕命名冲突。命名长，css选择时可尽量不使用子选择符，确保css优先级权重足够低。方便扩展时覆盖操作。 - 命名有意义，尽量采用英文。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id='id3952'&gt;二、注释规范&lt;/h4&gt;

&lt;p&gt;- 公共组件需要在文件头部加上注释说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/**
	* usage：
	* author：
	* email：
	* date：	
	**/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;- 大模块注释，用==分隔开：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	//===================
	//代码用途
	//===================&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;- 小功能注释，单独占一行，不要在代码后的同一行内加注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	//代码用途
	var name = &amp;quot;abc&amp;quot;;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id3953'&gt;公共组件开发规范&lt;/h4&gt;

&lt;h4 id='html'&gt;HTML规范&lt;/h4&gt;

&lt;h4 id='css'&gt;CSS规范&lt;/h4&gt;

&lt;h4 id='js'&gt;JS规范&lt;/h4&gt;</content>
 </entry>
 
 <entry>
   <title>FreeMarker学习笔记</title>
   <link href="http://heiniuhaha.github.com/freemarker/2012/11/02/freemarker"/>
   <updated>2012-11-02T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/freemarker/2012/11/02/freemarker</id>
   <content type="html">&lt;h3 id='1freemarkerrequestsession'&gt;1.freemarker中Request,Session的用法：&lt;/h3&gt;

&lt;p&gt;java块:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request.getSession().setAttribute(&amp;quot;qq&amp;quot;,&amp;quot;http://www.qq.com&amp;quot;);  
request.setAttribute(&amp;quot;qq&amp;quot;, &amp;quot;http://www.qq.com&amp;quot;);  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;freemarker代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if Session [&amp;quot;qq&amp;quot;]?exists&amp;gt;//Request的用法同session  
&amp;lt;#if Session [&amp;quot;qq&amp;quot;]==&amp;quot;http://www.qq.com&amp;quot;&amp;gt;  
&amp;lt;#else&amp;gt;  
&amp;lt;/#if&amp;gt;  
&amp;lt;#else&amp;gt;  
&amp;lt;/#if&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而通常情况下，Request和Session均可省去不写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if qq?exists&amp;gt;//Request的用法同session  
	&amp;lt;#if qq==&amp;quot;http://www.qq.com&amp;quot;&amp;gt;  
	&amp;lt;#else&amp;gt;  
	&amp;lt;/#if&amp;gt;  
&amp;lt;#else&amp;gt;  
&amp;lt;/#if&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果他们都设有相同的key值，那么在页面中显示的话，就就应该把他们加上去。&lt;/p&gt;

&lt;h3 id='2freemarkerjavascript'&gt;2.freemarker中导入样式表的写法，javascript的写法注意：&lt;/h3&gt;

&lt;p&gt;引入样式表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link href=&amp;quot;*.css&amp;quot; type=text/css rel=stylesheet&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加样式表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;  
  .imgs img{width:150px ; height:70px;}  
&amp;lt;/style&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;javascript块:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;  
   function method(para){}  
&amp;lt;/script&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='3'&gt;3.判断集合：&lt;/h3&gt;

&lt;p&gt;集合的集合：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if voteWraperObj.itemList?size gt 0&amp;gt;  
	&amp;lt;#list voteWraperObj.itemList as voteList&amp;gt;  
	&amp;lt;/#list&amp;gt;              
&amp;lt;/#if&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象的集合：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if softDetail?size gt 0&amp;gt;  
	&amp;lt;#list softDetail as softlist&amp;gt;  
	&amp;lt;/#list&amp;gt;  
&amp;lt;/#if&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于Session中存放的对象的属性的读取：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if Session [&amp;quot;userweb&amp;quot;].member?exists&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断数组是否存在 &amp;lt;#if list??&amp;gt;&lt;/p&gt;

&lt;h3 id='4switchcase'&gt;4.switch/case的用法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#switch type&amp;gt;  
	&amp;lt;#case &amp;quot;down&amp;quot;&amp;gt;  
		&amp;lt;#include &amp;quot;softdown.ftl&amp;quot;&amp;gt;  
		&amp;lt;#break&amp;gt;  
	&amp;lt;#case &amp;quot;photo&amp;quot;&amp;gt;  
		&amp;lt;#if para==&amp;quot;photoSquare&amp;quot;&amp;gt;  
			&amp;lt;#include &amp;quot;photo.ftl&amp;quot;&amp;gt;  
		&amp;lt;#elseif para==&amp;quot;photoWidth&amp;quot;&amp;gt;  
			&amp;lt;#include &amp;quot;photo.ftl&amp;quot;&amp;gt;  
		&amp;lt;#else&amp;gt;  
		&amp;lt;/#if&amp;gt;  
	&amp;lt;#break&amp;gt;  
&amp;lt;/#switch&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='5'&gt;5.时间类型在页面是如何才能正常显示的：&lt;/h3&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${newslist.pubTime?string(&amp;#39;yyyy-MM-dd&amp;#39;)}  
${newslist.pubTime?string(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;)}   &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='6'&gt;6.判断存在与否，以及是否有效：&lt;/h3&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if goodslist.f_goods_url?exists&amp;amp;&amp;amp;goodslist.f_goods_url?length gt 0&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='7default'&gt;7.&amp;#8221;default&amp;#8221;是如何使用的：&lt;/h3&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${qq?default(&amp;quot;http://www.qq.com&amp;quot;)}  
//即如果属性qq不存在，那么就是要default中的值替代。  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='8'&gt;8.&lt;code&gt;&amp;lt;#assign&amp;gt;&lt;/code&gt;的用法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign count=0&amp;gt;  
&amp;lt;#assign str=&amp;quot;12345&amp;quot;&amp;gt;  
&amp;lt;#list 0..9 as i&amp;gt;  
	&amp;lt;#assign count=count+1&amp;gt;   
	&amp;lt;#if i gt str?length&amp;gt;  
		${count}  
	&amp;lt;/#if&amp;gt;  
&amp;lt;/#list&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：7 8 9 10&lt;/p&gt;

&lt;h3 id='9freemarker'&gt;9.freemarker中如何截取字符串&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;exp?substring(from, toExclusive)&lt;/code&gt; &lt;code&gt;exp?substring(from)&lt;/code&gt; 实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${&amp;#39;abc&amp;#39;?substring(0)}//abc
${&amp;#39;abc&amp;#39;?substring(0, 3)} //abc
${&amp;#39;abc&amp;#39;?substring(2, 3)} //c&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='10freemarker'&gt;10.freemarker页面中如果包含&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign html=JspTaglibs[&amp;quot;/WEB-INF/struts-html.tld&amp;quot;]&amp;gt;  
&amp;lt;@html.base/&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么它所指向的路径都是相对路径(相对于当前文件)。&lt;/p&gt;

&lt;h3 id='11freemarkerhtml'&gt;11.如何让freemarker模板当html来使用呢：（完整的页面如下）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;  
&amp;lt;head&amp;gt;  
    &amp;lt;#assign html=JspTaglibs[&amp;quot;/WEB-INF/struts-html.tld&amp;quot;]&amp;gt;  
    &amp;lt;#assign bean=JspTaglibs[&amp;quot;/WEB-INF/struts-bean.tld&amp;quot;]&amp;gt;  
    &amp;lt;#assign logic=JspTaglibs[&amp;quot;/WEB-INF/struts-logic.tld&amp;quot;]&amp;gt;  
    &amp;lt;@html.base/&amp;gt;  
    &amp;lt;link href=&amp;quot;css/main.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; /&amp;gt;  
    &amp;lt;meta http-equiv=&amp;quot;content-type&amp;quot; content=&amp;quot;text/html; charset=&amp;quot;utf-8&amp;quot;&amp;gt;  
 &amp;lt;/head&amp;gt;  
 &amp;lt;body&amp;gt;  
    ---------freemarker代码块  
 &amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='12int'&gt;12.使用内建的int获得整数部分&lt;/h3&gt;

&lt;p&gt;如&lt;code&gt;${1.1?int} = 1&lt;/code&gt;&lt;/p&gt;

&lt;h3 id='13'&gt;13.比较操作符：&lt;/h3&gt;

&lt;p&gt;* 使用=（或==，完全相等）测试两个值是否相等，使用!= 测试两个值是否不相等。&lt;br /&gt;* 对数字和日期可以使用&amp;lt;、&amp;lt;=、&amp;gt;和&amp;gt;=，但不能用于字符串&lt;br /&gt;* 由于Freemarker会将&amp;gt;解释成FTL标记的结束字符，所以对于&amp;gt;和&amp;gt;=可以使用括号来避免这种情况，例如&lt;code&gt;&amp;lt;#if (x &amp;gt; y)&amp;gt;&lt;/code&gt;，另一种替代的方法是，使用&lt;code&gt;lt&lt;/code&gt;、&lt;code&gt;lte&lt;/code&gt;、&lt;code&gt;gt&lt;/code&gt;和&lt;code&gt;gte&lt;/code&gt;来替代&amp;lt;、&amp;lt;=、&amp;gt;和&amp;gt;=&lt;/p&gt;

&lt;h3 id='14'&gt;14.内建函数：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;html：对字符串进行HTML编码&lt;/li&gt;

&lt;li&gt;cap_first：使字符串第一个字母大写&lt;/li&gt;

&lt;li&gt;lower_case：将字符串转换成小写&lt;/li&gt;

&lt;li&gt;upper_case：将字符串转换成大写&lt;/li&gt;

&lt;li&gt;trim：去掉字符串前后的空白字符&lt;/li&gt;

&lt;li&gt;size：获得序列中元素的数目&lt;/li&gt;

&lt;li&gt;int：取得数字的整数部分（如-1.9?int的结果是-1）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='15'&gt;15.将表达式结果转换成文本输出&lt;/h3&gt;

&lt;p&gt;根据缺省格式（由#setting指令设置）将表达式结果转换成文本输出；可以使用内建函数string格式化单个Interpolation&lt;br /&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#setting number_format=&amp;quot;currency&amp;quot;/&amp;gt;  
&amp;lt;#assign answer=42/&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果是：$42.00&lt;br /&gt;单个Interpolation：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${answer?string.number}  
${answer?string.currency}  
${answer?string.percent}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='16_'&gt;16. 插入日期值：&lt;/h3&gt;

&lt;p&gt;根据缺省格式（由#setting指令设置）将表达式结果转换成文本输出；可以使用内建函数string格式化单个Interpolation&lt;br /&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${lastUpdated?string(&amp;quot;yyyy-MM-dd HH:mm:ss zzzz&amp;quot;)}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='17session'&gt;17.Session中设置对象属性的判断：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Session [&amp;quot;userweb&amp;quot;].member?exists&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='18_'&gt;18. 插入布尔值：&lt;/h3&gt;

&lt;p&gt;根据缺省格式（由#setting指令设置）将表达式结果转换成文本输出；可以使用内建函数string格式化单个Interpolation.&lt;br /&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign or=true/&amp;gt;  
${or?string(&amp;quot;You are right!&amp;quot;, &amp;quot;You are wrong!&amp;quot;)}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：You are right!&lt;/p&gt;

&lt;h3 id='19_'&gt;19. 格式化数字&lt;/h3&gt;

&lt;p&gt;数字Interpolation的#{expr; format}形式可以用来格式化数字，format可以是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mX：小数部分最小X位&lt;/li&gt;

&lt;li&gt;MX：小数部分最大X位&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign x=2.582/&amp;gt;  
&amp;lt;#assign y=4/&amp;gt;  
#{x; M2}   &amp;lt;#-- 2.58 --&amp;gt;  
#{y; M2}   &amp;lt;#-- 4    --&amp;gt;  
#{x; m1}   &amp;lt;#-- 2.6 --&amp;gt;  
#{y; m1}   &amp;lt;#-- 4.0 --&amp;gt;  
#{x; m1M2} &amp;lt;#-- 2.58 --&amp;gt;  
#{y; m1M2} &amp;lt;#-- 4.0 --&amp;gt;   &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='20'&gt;20.用户定义指令：宏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#macro greet person&amp;gt;  
&amp;lt;font size=&amp;quot;+2&amp;quot;&amp;gt;Hello ${person}!&amp;lt;/font&amp;gt;  
&amp;lt;/#macro&amp;gt;   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为用户定义指令使用宏变量时，使用@替代FTL标记中的#&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;@greet person=&amp;quot;Fred&amp;quot;/&amp;gt; and &amp;lt;@greet person=&amp;quot;Batman&amp;quot;/&amp;gt;   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：Hello Fred! and Hello Batman!&lt;/p&gt;

&lt;h3 id='21_'&gt;21： 宏可以有多参数：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#macro greet person color&amp;gt;  
	&amp;lt;font size=&amp;quot;+2&amp;quot; color=&amp;quot;${color}&amp;quot;&amp;gt;Hello ${person}!&amp;lt;/font&amp;gt;  
&amp;lt;/#macro&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以这样使用该宏变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;@greet person=&amp;quot;Fred&amp;quot; color=&amp;quot;black&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中参数的次序是无关的，只能使用在macro指令中定义的参数，并且对所有参数赋值，所以下面的代码是错误的：&lt;br /&gt;只能使用在macro指令中定义的参数，并且对所有参数赋值，多了或者少了都会出错的，完全赋值。 如：&lt;code&gt;&amp;lt;@greet person=&amp;quot;Fred&amp;quot;/&amp;gt;&lt;/code&gt;为错。&lt;/p&gt;

&lt;p&gt;可以在定义参数时指定缺省值，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#macro greet person color=&amp;quot;black&amp;quot;&amp;gt;  
	&amp;lt;font size=&amp;quot;+2&amp;quot; color=&amp;quot;${color}&amp;quot;&amp;gt;Hello ${person}!&amp;lt;/font&amp;gt;  
&amp;lt;/#macro&amp;gt;   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样&lt;code&gt;&amp;lt;@greet person=&amp;quot;Fred&amp;quot;/&amp;gt;&lt;/code&gt;就正确了，宏的参数是局部变量，只能在宏定义中有效。&lt;/p&gt;

&lt;h3 id='22_'&gt;22. 嵌套内容&lt;/h3&gt;

&lt;p&gt;用户定义指令可以有嵌套内容，使用&amp;lt;#nested&amp;gt;指令执行指令开始和结束标记之间的模板片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#macro border&amp;gt;  
	&amp;lt;table border=4 cellspacing=0 cellpadding=4&amp;gt;
		&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;#nested&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
	&amp;lt;/table&amp;gt;  
&amp;lt;/#macro&amp;gt;   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样使用该宏变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;@border&amp;gt;The bordered text&amp;lt;/@border&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table border=4 cellspacing=0 cellpadding=4&amp;gt;
	&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;The bordered text&amp;lt;/tr&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/table&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='23_list'&gt;23. list循环中索引值&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;item_index:这是一个包含当前项在循环中的步进索引的数值。&lt;/li&gt;

&lt;li&gt;item_has_next:来辨别当前项是否是序列的最后一项的布尔值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign seq = [&amp;quot;winter&amp;quot;, &amp;quot;spring&amp;quot;, &amp;quot;summer&amp;quot;, &amp;quot;autumn&amp;quot;]&amp;gt; 
&amp;lt;#list seq as x&amp;gt;		${x_index + 1}. ${x}&amp;lt;#if x_has_next&amp;gt;,&amp;lt;/#if&amp;gt; 	&amp;lt;/#list&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. winter, 2. spring, 3. summer, 4. autumn&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>javascript高级特性学习笔记</title>
   <link href="http://heiniuhaha.github.com/javascript/2012/10/26/javascript-essence"/>
   <updated>2012-10-26T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/javascript/2012/10/26/javascript-essence</id>
   <content type="html">&lt;h2 id='javascript'&gt;javascript高级特性学习笔记&lt;/h2&gt;

&lt;h3 id='id3949'&gt;编程理念:&lt;/h3&gt;

&lt;p&gt;面向对象、函数式编程、闭包、动态绑定、作用域&lt;/p&gt;

&lt;h4 id='1'&gt;1、作用域&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;概念：&lt;/strong&gt; 命名冲突、函数作用域&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;搜索顺序：&lt;/strong&gt; 局域作用域-&amp;gt;上层作用域-&amp;gt;全局作用域&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;全局对象：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在Node.js对应的是global对象&lt;/li&gt;

&lt;li&gt;在浏览器中对应的是window对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;全局作用域：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最外层定义的变量，如 &lt;code&gt;var global;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;全局对象的属性，如&lt;code&gt;$.util.pagin&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;任何地方隐式定义的变量（未定义直接赋值），如&lt;code&gt;global=&amp;quot;aaa&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='2'&gt;2、闭包&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个函数返回它内部定义的一个函数时，就产生了一个闭包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;code：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var generateClosure = function(){
	var count = 0;
	var get = function(){
		count ++;
		return count;
	};
	return get;
};
var counter1 = generateClosure();
var counter2 = generateClosure();

console.log(counter1());//1
console.log(counter2());//1
console.log(counter1());//2
console.log(counter1());//3
console.log(counter2());//2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;调用函数时，生成两个闭包实例，在内存中生成了相互独立的副本，它们内部引用的count变量分别属于各自的运行环境。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用途：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;- 嵌套的回调函数 - 实现js对象私有成员，防止被外部调用时修改破坏，按非正式约定需加下划线前缀。此处模拟方式：把一个对象用闭包封装起来，只返回一个“访问器”的对象，即可实现对细节隐藏。&lt;/p&gt;

&lt;h3 id='3'&gt;3、对象&lt;/h3&gt;

&lt;h3 id='id3950'&gt;什么是前端，前端的意义&lt;/h3&gt;</content>
 </entry>
 
 <entry>
   <title>javascript面向对象编程浅析</title>
   <link href="http://heiniuhaha.github.com/javascript/2012/09/20/oop"/>
   <updated>2012-09-20T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/javascript/2012/09/20/oop</id>
   <content type="html">&lt;h3 id='id3941'&gt;什么是面向对象&lt;/h3&gt;

&lt;p&gt;面向对象最基本的三大特性是继承、封装、多态，javascript不是面向对象的语言，但能实现继承和封装两个特性。 js中的对象&lt;/p&gt;

&lt;h3 id='id3942'&gt;弱类型&lt;/h3&gt;

&lt;p&gt;定义变量类型：&lt;/p&gt;

&lt;p&gt;布尔型bool、数值型、字符串类型、函数类型、数组类型、空类型、未定义类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = &amp;quot;&amp;quot;; //字符串
var b = []; //数组
var c = function(){} //function函数
var d = {}; //对象&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字面量:&lt;/p&gt;

&lt;p&gt;字面量就类似于我们使用的json数据格式，分为字符串字面量、数组字面量、函数字面量、对象字面量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cat = {
	//字符串字面量
	name : &amp;quot;cat&amp;quot;,
	
	//数组字面量
	type : [&amp;quot;波斯猫&amp;quot;, &amp;quot;加菲猫&amp;quot;, &amp;quot;垂耳猫&amp;quot;],
	
	//函数字面量
	mark : function(){alert(this.name + this.type)},
	
	//对象字面量
	info : {from : &amp;quot;usa&amp;quot;, &amp;quot;age&amp;quot; : &amp;quot;1&amp;quot;}
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='js'&gt;创建js对象&lt;/h3&gt;

&lt;p&gt;js对象只是一组名称/值对，可以使用熟悉的“.”（点）运算符或“&lt;span /&gt;”运算符，来获得和设置对象的属性，像词典。&lt;/p&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = new Object();
userObject.lastLoginTime = new Date();
alert(userObject.lastLoginTime); &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = {}; // equivalent to new Object()
userObject[&amp;quot;lastLoginTime&amp;quot;] = new Date();
alert(userObject[&amp;quot;lastLoginTime&amp;quot;]);   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code3：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = { 
	&amp;quot;lastLoginTime&amp;quot; : new Date() 
};
alert(userObject.lastLoginTime);&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='js'&gt;创建js函数，函数也是对象&lt;/h3&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1、普通函数
function func(x) {
    alert(x);
}
func(&amp;quot;blah&amp;quot;);

//2、定义函数，在此创建函数对象，并赋给变量func
var func = function(x) {
    alert(x);
};
func(&amp;quot;blah2&amp;quot;);

//3、用Funciton构造函数，不常用
var func = new Function(&amp;quot;x&amp;quot;, &amp;quot;alert(x);&amp;quot;);
func(&amp;quot;blah3&amp;quot;);	&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id3943'&gt;使用对象初始化器创建对象&lt;/h3&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myConstructor = function(){
}

//添加静态属性
//name属性和alertName()方法作为静态成员添加到了对象实例中
myConstructor.name = &amp;quot;heiniu&amp;quot;;
myConstructor.alertName = function(){
	alert(this.name);
}
//执行,不需要new
myConstructor.alertName();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code2：等价于以下代码，结构更简洁清晰。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//name属性和alertName()方法作为静态成员添加到了对象实例中
var myConstructor = {
	//静态属性
	name : &amp;quot;heiniu&amp;quot;,
	
	//静态方法
	alertName : function(){
		alert(this.name);
	}
}

//执行,不需要new
myConstructor.alertName();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;- 优点：简洁明了； - 缺点：创建对象的代码是一次性的&lt;/p&gt;

&lt;h3 id='id3944'&gt;使用构造函数创建对象&lt;/h3&gt;

&lt;p&gt;定义构造函数，而不是类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//私有成员就是在构造函数中定义的变量和函数
function myConstructor2(msg, name){

	//公有属性
	this.myMsg = msg;
	this.name = name;
	
	//私有属性
	var myVersion = &amp;quot;1.0&amp;quot; 
	
	//私有方法
	function alertMsg(){
		alert(this.myMsg)
		alert(myVersion)
	}
	alertVersion();//实例化时显示信息
	
	//特权方法，也是公用方法，在构造函数的作用域中使用this关键字定义的方法，尽量不要用，只用于需要访问私有成员的情况。
	this.appendToMsg = fucntion(string){
		this.myMsg += &amp;quot;heiniu_&amp;quot; + string;
		alertMsg();
	}
	
}

//静态属性和方法，静态成员是直接通过类对象访问的。
myConstructor2.myYear = &amp;quot;2012&amp;quot;;
myConstructor2.now = function(){
	return new Date();
}

//公有方法，修改函数原型，即prototype属性。
//一旦修改原型方法则立即应用到继承的对象和实例中，有风险。
//原型方式会将新方法添加到myConstructor2的底层定义中，而不是myConstructor2实例自身。
myConstructor2.prototype.alertMsg(){
	alert(this.myMsg);
}
myConstructor2.prototype.alertName(){
	alert(this.name);
}

var myObj = new myConstructor2(&amp;quot;hello&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new操作符等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1、call()方法,每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。第一个参数用作 this 的对象。其他参数都直接传递给函数自身。
var myObj = {};
myConstructor2.call(myObj,&amp;quot;hello&amp;quot;, &amp;quot;heiniu&amp;quot;)

//2、apply()方法，有两个参数，用作 this 的对象和要传递给函数的参数的数组。
var myObj = {};
myConstructor2.apply(myObj,[&amp;quot;hello&amp;quot;, &amp;quot;heiniu&amp;quot;])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;call的工作机制：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var someuser = {
	name : &amp;quot;sjm&amp;quot;,
	display : function(words){
		console.log(this.name + &amp;#39; says &amp;#39; + words);
	}
};

var myself = {
	name : &amp;quot;heiniu&amp;quot;
};

someuser.display.call(myself, &amp;#39;fighting!&amp;#39;);
//结果：heiniu says fighting!&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;someuser.display是函数的引用，即被调用的函数。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;myself是someuser.display被调用时的上下文对象。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&amp;#8216;fighting!&amp;#8217;是传入someuser.display的参数。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;通过call将上下文对象改变为myself对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。&lt;/p&gt;

&lt;p&gt;call和apply的功能一致：以不同的对象作为上下文来调用某个函数，即允许一个对象去调用另一个对象的成员函数。&lt;/p&gt;

&lt;p&gt;call和apply的差别：call以参数表来接受被调用函数的参数，而apply以数组来接受被调用函数的参数。&lt;/p&gt;

&lt;p&gt;使用不同的引用来调用同一个函数时，this指针永远是这个引用所属的对象。&lt;/p&gt;

&lt;p&gt;- 优点：可创建出多个规划好的对象，有若干个固定的属性、方法，并能初始化实例化。 - 缺点：复杂些，有上下文对象（this指针），即被调用函数所处的环境。&lt;/p&gt;

&lt;h3 id='id3945'&gt;使用原型和构造函数共同生成对象&lt;/h3&gt;

&lt;p&gt;什么是原型链？&lt;/p&gt;

&lt;p&gt;继承方面,javascript中的每个对象都有一个内部私有的链接指向另一个对象 (或者为 null),这个对象就是原对象的原型. 这个原型也有自己的原型, 直到对象的原型为null为止. 这种一级一级的链结构就称为原型链.&lt;/p&gt;

&lt;p&gt;prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function ClassA() {
}

ClassA.prototype.color = &amp;quot;blue&amp;quot;;
ClassA.prototype.sayColor = function () {
    alert(this.color);
};

function ClassB() {
}

//继承和扩展
ClassB.prototype = new ClassA();
ClassB.prototype.name = &amp;quot;&amp;quot;;
ClassB.prototype.sayName = function () {
    alert(this.name);
};

//执行
var objA = new ClassA();
var objB = new ClassB();
objA.color = &amp;quot;blue&amp;quot;;
objB.color = &amp;quot;red&amp;quot;;
objB.name = &amp;quot;John&amp;quot;;
objA.sayColor();
objB.sayColor();
objB.sayName();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用原型与直接在构造函数内定义的属性 不同点：&lt;/p&gt;

&lt;p&gt;- 构造函数内定义的属性继承方式与原型不同，子对象需要显示调用父对象才能继承构造函数内定义的属性。 - 构造函数内定义的任何属性，包括函数在内都会被重复创建，同一个构造函数产生的两个对象不共享实例。 - 构造函数内定义的函数有运行时闭包的开销，因为构造函数内的局部变量对其中定义的函数来说是可见的。&lt;/p&gt;

&lt;p&gt;原型使用场合：&lt;/p&gt;

&lt;p&gt;- 除非必须用构造函数闭包，否则尽量用原型定义成员函数，可减少开销 - 尽量在构造函数内定义一般成员，尤其是对象或数组，因为用原型定义的成员是多个实例共享的。&lt;/p&gt;

&lt;h3 id='id3946'&gt;原型链机制：&lt;/h3&gt;

&lt;p&gt;javascript分为三类对象：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1、用户创建的对象&lt;/li&gt;

&lt;li&gt;2、构造函数对象&lt;/li&gt;

&lt;li&gt;3、原型对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo(){
}
var foo = new Foo();
var obj = new Object();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关系图如下： &lt;img alt='原型链关系图' src='/images/prototype-1024x702.png' /&gt;&lt;/p&gt;

&lt;h3 id='id3947'&gt;公有、私有、特权、静态总结&lt;/h3&gt;

&lt;p&gt;- 私有和特权成员在函数的内部，他们会被带到函数的每一个实例中生成新的副本，因而将占用大量的内存。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;公有的原型成员是对象的一部分，适用于通过new关键字实例化该对象的每一个实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;- 静态成员所关联的是类本身，而不同的是大多数方法和属性所关联的是类的实例。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;私有成员命名规范上用下划线表示，私有成员可避免安全隐患，防止使用者修改某个属性，导致对象内部数据的一致性受到破坏。如&lt;code&gt;_myPrivateProp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id3948'&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx'&gt;http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp'&gt;http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>IE盒模型与W3C盒模型浅总结</title>
   <link href="http://heiniuhaha.github.com/css/2012/09/09/css-box-model"/>
   <updated>2012-09-09T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/css/2012/09/09/css-box-model</id>
   <content type="html">&lt;p&gt;css:层叠样式表（Cascading Style Sheets）&lt;/p&gt;

&lt;h3 id='demo'&gt;demo：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.heiniuhaha.com/demo/css-box-model/css-box-model-W3C.html'&gt;http://www.heiniuhaha.com/demo/css-box-model/css-box-model-W3C.html&lt;/a&gt; 声明doctype&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.heiniuhaha.com/demo/css-box-model/css-box-model-IE.html'&gt;http://www.heiniuhaha.com/demo/css-box-model/css-box-model-IE.html&lt;/a&gt; 不声明doctype&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;code ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt; 
	div{
		background-color:red;
		width:300px;
		height:300px;
		padding:20px;
		margin:100px;
		border:10px solid #000;
	}
	/*ie6不支持透明transparent*/
	.box2{border-color:transparent}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;box2&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chrome测试图：&lt;/p&gt;

&lt;p&gt;&lt;img alt='chrome测试图' src='http://www.heiniuhaha.com/demo/css-box-model/css-box-model-chrome.png' /&gt;&lt;/p&gt;

&lt;p&gt;IE6测试图-IE盒模型和W3C标准盒模型对比图：&lt;/p&gt;

&lt;p&gt;&lt;img alt='IE6测试图-标准和非标准' src='http://www.heiniuhaha.com/demo/css-box-model/box-ie6.png' /&gt;&lt;/p&gt;

&lt;h3 id='id3934'&gt;盒模型示意图&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;IE盒模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt='IE盒模型' src='http://www.heiniuhaha.com/demo/css-box-model/p2.gif' /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;W3C标准盒模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt='W3C标准盒模型' src='http://www.heiniuhaha.com/demo/css-box-model/p3.gif' /&gt;&lt;/p&gt;

&lt;h3 id='id3935'&gt;总结：&lt;/h3&gt;

&lt;p&gt;IE盒模型占总空间=contentWidth，内容区只占了一小部分空间；&lt;/p&gt;

&lt;p&gt;w3c标准盒模型占总空间=contentWidth+padding+margin+border；&lt;/p&gt;

&lt;p&gt;同时：div的背景颜色充满了padding和border区域，border透明时，可发现背景颜色就是div的bgcolor.（ie6不支持透明transparent）&lt;/p&gt;

&lt;h3 id='id3936'&gt;触发盒模型&lt;/h3&gt;

&lt;p&gt;IE6 IE7 IE8 IE9 在Quirks怪异模式下，盒模型是一模一样的，都是IE盒模型，即总width=width;&lt;/p&gt;

&lt;p&gt;IE6 IE7 IE8 IE9 在标准模式下，盒模型也是一模一样的，都是W3C盒模型， 即总width=width+padding+border;&lt;/p&gt;

&lt;p&gt;非IE下的浏览器，如FF、chrome都采用标准模式渲染，都是W3C盒模型， 即总width=width+padding+border;&lt;/p&gt;

&lt;h3 id='border'&gt;border区域是否填充背景色&lt;/h3&gt;

&lt;p&gt;border区域不填充背景色图&lt;/p&gt;

&lt;p&gt;&lt;img alt='border区域不填充背景色' src='http://www.heiniuhaha.com/demo/css-box-model/border-transparent-ie7.png' /&gt;&lt;/p&gt;

&lt;p&gt;border区域填充背景色图&lt;/p&gt;

&lt;p&gt;&lt;img alt='border区域填充背景色' src='http://www.heiniuhaha.com/demo/css-box-model/border-transparent-ie8.png' /&gt;&lt;/p&gt;

&lt;h4 id='id3937'&gt;标准模式下&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非IE浏览器下，div的背景颜色充满了padding和border。border透明时，可发现border区域填充了背景色。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;IE8和IE9在标准模式下，和非IE浏览器渲染一致，border区域填充背景色；&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;IE6 IE7标准模式下，border区域不填充背景色；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id='id3938'&gt;非标准模式下&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;IE6 IE7 IE8 IE9在Quirks怪异模式下，border区域都不会填充背景色；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id3939'&gt;备注：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;lt;!DOCTYPE&amp;gt; is not an HTML tag. It is an information (a declaration) to the browser about what version the HTML is written in. 声明帮助浏览器正确地显示网页。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;HTML规定了三种文档类型：Strict、Transitional 以及 Frameset。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;在没有声明doctype的情况下，浏览器选择自己的模式，怪异模式(QUICK MODE)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id3940'&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://www.w3schools.com/css/css_boxmodel.asp'&gt;w3schools.com css box model&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://blog.csdn.net/ncode/article/details/7428746'&gt;IE6与W3C标准的盒模型差异&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>seajs模块依赖的加载处理</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/26/seajs-require-theory"/>
   <updated>2012-08-26T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/26/seajs-require-theory</id>
   <content type="html">&lt;h3 id='seajs'&gt;seajs模块依赖问题&lt;/h3&gt;

&lt;p&gt;最近在做项目的时候发现一些关于模块依赖问题，特记录下:&lt;/p&gt;

&lt;p&gt;比如现有3个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*init.js*/
define(function(require, exports, module){
	require(&amp;#39;jquery&amp;#39;);
	require(&amp;#39;jquery.plugA&amp;#39;);
})

/*jquery.plugA.js*/
define(function(require, exports, module){
	require(&amp;#39;jquery&amp;#39;);
	require(&amp;#39;jquery.plugB&amp;#39;);
	//code...
})

/*jquery.plugB.js*/
define(functioin(require, exports, module){
	require(&amp;#39;jquery&amp;#39;);
	//code...
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如执行init.js时，init.js、jquery.plugA.js、jquery.plugB.js都会依赖到jquery，那么这种情况下seajs对jquery如何处理的呢？只执行一次？执行多次？还是其他方式？&lt;/p&gt;

&lt;p&gt;此处参考玉伯的回答：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我对模块调用的理解是，调用是指获取某个模块的接口。在 SeaJS 里，只有 seajs.use, require.async, 和 require 会产生&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;模块调用，比如： &lt;code&gt;var a = require(&amp;#39;./a&amp;#39;)&lt;/code&gt; 在执行 require(&amp;#8216;./a&amp;#8217;) 时，会获取模块的接口，如果是第一次调用，会初始化模块 a，以后再调用时，直接返回模块 a 的接口 define 只是注册模块信息，比如打包之后： &lt;code&gt;define(id, deps, factory)&lt;/code&gt; 是注册了一个模块到 seajs.cache 中，define 类似： &lt;code&gt;seajs.cache[id] = { id: id, dependencies: deps, factory: factory }&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;是纯注册信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;而 &lt;code&gt;require(&amp;#39;./a&amp;#39;)&lt;/code&gt; 时，才会执行 &lt;code&gt;seajs.cache[&amp;#39;a&amp;#39;].factory&lt;/code&gt;, 执行后得到 &lt;code&gt;seajs.cache[&amp;#39;a&amp;#39;].exports&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote /&gt;

&lt;h3 id='uriurl'&gt;扩展：URI与URL的区别&lt;/h3&gt;

&lt;p&gt;URI:Uniform Resource Identifiers ，统一资源标识符；&lt;/p&gt;

&lt;p&gt;URL:Uniform Resource Locators ，统一资源定位符；&lt;/p&gt;

&lt;p&gt;URN:Uniform Resource Names，统一资源名称&lt;/p&gt;

&lt;p&gt;URL,URN是URI的子集.&lt;/p&gt;

&lt;h3 id='id3933'&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Module.STATUS的具体含义：&lt;a href='https://github.com/seajs/seajs/issues/303'&gt;https://github.com/seajs/seajs/issues/303&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;分清 URI、URL 和 URN&lt;a href='http://www.ibm.com/developerworks/cn/xml/x-urlni.html'&gt;http://www.ibm.com/developerworks/cn/xml/x-urlni.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>【转】jQuery 模块介绍与 jQuery 插件的深度模块化</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/15/seajs-jquery-plugin"/>
   <updated>2012-08-15T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/15/seajs-jquery-plugin</id>
   <content type="html">&lt;p&gt;转自玉伯 &lt;a href='http://lifesinger.wordpress.com/2011/08/19/jquery-introduction-and-plugins-modulization/'&gt;jQuery 模块介绍与 jQuery 插件的深度模块化&lt;/a&gt;,方便不能翻墙的同学查看。&lt;/p&gt;

&lt;h2 id='jquery'&gt;jQuery模块&lt;/h2&gt;

&lt;p&gt;大名鼎鼎的 jQuery 就不多介绍了，详细介绍推荐官网：jquery.com 阮一峰最近整理的文章也不错，推荐：&lt;a href='http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html'&gt;jQuery 设计思想&lt;/a&gt;, &lt;a href='http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html'&gt;jQuery 最佳实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;几点感悟：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;jQuery 是 DOM 操作类库，其核心功能是找到 DOM 元素并对其进行操作。&lt;/li&gt;

&lt;li&gt;拿 jQuery 与 YUI, Dojo 等框架相比是不公平的，就如拿轮胎和汽车相比一样。jQuery 只是一个轮胎，功能很单一，YUI 和 Dojo 等则是相对完整的汽车，除了轮胎，还有引擎、外壳等等。&lt;/li&gt;

&lt;li&gt;说 jQuery 不适合构建大型应用，就如说轮胎不适合参加赛车比赛一样不合逻辑。你可以用 jQuery 做轮胎，然后选择其他部件组合起来去 DIY 一辆赛车。能否胜出，得看赛车手的 DIY 水准。&lt;/li&gt;

&lt;li&gt;jQuery的困局在于 DIY 高手不多，经常是一个好轮胎挂上一堆破破烂烂的外壳就上前线了。jQuery 的破局也在于 DIY. DIY 意味着灵活、可替换性，意味着可快速前行和高性能。&lt;/li&gt;

&lt;li&gt;jQuery 灵活性带来的缺陷，比如有可能由选择器和链式风格导致的低效 DOM 操作，目前在提供了同类功能的 YUI3 等类库中同样存在。这不是类库的问题，更多是因为使用者的经验欠缺导致的。就如一把优秀的菜刀，到了一个拙劣的厨子手中，依旧切不好菜一样。工具很重要，但更重要的是我们得提升自己的刀工。&lt;/li&gt;

&lt;li&gt;最后，回到第一点：jQuery 是 DOM 操作类库。非 DOM 操作，都是 jQuery 的辅助功能，不是 jQuery 的强项，就如菜刀不能当斧头用一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可以通过简单封装，让 jQuery 成为 CommonJS 的模块。这样，调用时只要 require 即可：&lt;/p&gt;

&lt;p&gt;test.html:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;http://modules.seajs.com/libs/seajs/1.0.1/sea.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
seajs.use(&amp;#39;./init&amp;#39;);
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.js:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;seajs.config({
  alias: {
    &amp;#39;juery&amp;#39;: &amp;#39;jquery/1.6.1/jquery&amp;#39;
  }
});

define(function(require, exports, module) {
  var $ = require(&amp;#39;jquery&amp;#39;);
  // do something with jQuery
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='jquery'&gt;jQuery插件的模块化&lt;/h2&gt;

&lt;p&gt;jQuery 提供了 DOM 操作功能，在实际应用中，我们还需要 cookie, template, storage 等等一系列功能。这时可以从 jQuery 社区中寻找各种插件来完成。大部分插件通过 jQuery 插件的模块化 一文中提供的方法封装就好。&lt;/p&gt;

&lt;p&gt;之前的封装方法，总结成一句话是：“jQuery 穿肠过，插件身上留”。正如 Kidwind 反馈的一样，每次“穿肠过”的时候都要运行一次插件代码，频繁调用某些插件时，会存在 CPU 浪费，还可能带来隐患：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;假设有以下jquery插件a, b, c, d，它们之间的关系如下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;b 依赖于 a&lt;/li&gt;

&lt;li&gt;c 依赖于 a&lt;/li&gt;

&lt;li&gt;d 依赖于 b c&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;假设页面使用到d插件，那么插件a将进行两次初始化，也就是会调用两次&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;var $ = require(&amp;#39;jquery&amp;#39;);require(&amp;#39;a&amp;#39;)($);&lt;/code&gt; 进行插件a的注册，当系统复杂时，重复的插件注册会不会影响系统的性能，同时会不会存在隐患？如插件b对引用的插件a进行了部分功能扩展，当引入插件c的时候又重新注册了插件a，那么插件b对插件a的扩展将不存在了，当然改写插件功能的实际情况也许不会存在，此处只是举个例子，说明隐患的存在。 如何避免重复的插件注册，可以避免隐患，同时获得更好的性能（避免了多次插件注册的运算耗时）。&lt;/p&gt;

&lt;p&gt;面对这种情况，我们究竟应该如何做好 jQuery 插件的模块化？&lt;/p&gt;

&lt;p&gt;jQuery 插件的形式&lt;/p&gt;

&lt;p&gt;jQuery 插件一般可以总结为以下模板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function($) {  
  // Main plugin function
  $.fn.PLUGIN = function(options) {
    // snip...
  };

  // Public plugin function
  $.fn.PLUGIN.FUNCT = function() {
    // Cool JS action
  };

  // Default settings for the plugin
  $.fn.PLUGIN.defaults = { /* snip... */ };

  // Private function that is used within the plugin
  // snip...
})(jQuery);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简言之就是往 &lt;code&gt;$.fn&lt;/code&gt; 上添加新成员，有部分插件还会往 &lt;code&gt;$&lt;/code&gt; 上添加成员。&lt;/p&gt;

&lt;p&gt;之前的“穿肠过”模块化方式，可以表示为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function() { return function($) {
  $.fn.PLUGIN = ...
}});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
  var $ = require(&amp;#39;jquery&amp;#39;);
  require(&amp;#39;some-jquery-plugin&amp;#39;)($);

  $(sth).PLUGIN(...);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不是很直观，不够方便，还有前面提到的隐患。&lt;/p&gt;

&lt;p&gt;深度模块化&lt;/p&gt;

&lt;p&gt;为了更好的模块化，意味着我们要添加更多代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {
  var $ = require(&amp;#39;jquery&amp;#39;).sub();

  // Main plugin function
  $.fn.PLUGIN = function(options) {
    // snip...
  };

  // Public plugin function
  $.fn.PLUGIN.FUNCT = function() {
    // Cool JS action
  };

  // Default settings for the plugin
  $.fn.PLUGIN.defaults = { /* snip... */ };

  // Private function that is used within the plugin
  // snip...

  module.exports = $;
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样封装后，调用变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
  var $ = require(&amp;#39;jquery&amp;#39;);
  var PLUGIN = require(&amp;#39;some-jquery-plugin&amp;#39;);
  PLUGIN(sth).PLUGIN(...);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样能解决之前提到的重复初始化问题，但是 &lt;code&gt;PLUGIN(sth).PLUGIN(…)&lt;/code&gt; 的使用方式怪怪的。比如这个非常帅的 chosen 插件，按照上面的方式模块化后，调用方式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chosen(&amp;#39;#some-id&amp;#39;).chosen();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然可用，但怎么看怎么别扭。这是因为 jQuery 是以 DOM 为中心的，代码的默认流程是找到要操作的 DOM 元素，然后对其进行操作。这种代码书写方式，对于模块后的插件来说，很别扭。更好的期待中的调用方式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
  var $ = require(&amp;#39;jquery&amp;#39;);
  var Chosen = require(&amp;#39;chosen&amp;#39;);
 
  var chosen = new Chosen(selector, options);
  chosen.doSth(...);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理论上，我们甚至可以不知道 chosen 依赖 jQuery, 我们需要关心的只是 chosen 的 API. 上面这种理想的调用方式，需要我们对插件进行“深度”模块化：&lt;/p&gt;

&lt;p&gt;some-jquery-plugin.js:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {
  var $ = require(&amp;#39;jquery&amp;#39;);

  // Main plugin function
  function PLUGIN(selector, options) {
    var els = $(selector);
    // snip...
  };

  // Public plugin function
  PLUGIN.FUNCT = function() {
    // Cool JS action
  };

  // Default settings for the plugin
  PLUGIN.defaults = { /* snip... */ };

  // Private function that is used within the plugin
  // snip...

  module.exports = PLUGIN;
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，在 plugin 的代码里，我们并不对 $.fn 或 $ 进行扩展，只用 $ 来进行 DOM 操作而已，返回的是独立的 PLUGIN 对象，就和我们写普通的业务模块一样。这样，就实现预期中更优雅的调用方式。&lt;/p&gt;

&lt;p&gt;jQuery 的插件机制，在模块化面前很鸡肋。jQuery 一直被冠以“不适合大型项目”，也和 jQuery 的这种插件机制有关系。这会导致大家都去污染 $.fn, 这就和污染全局变量一样。项目一大，冲突的概率，和调试的成本都会变大，很悲剧。&lt;/p&gt;

&lt;p&gt;因此，推荐大家利用模块的机制去重构一部分好用的 jQuery 插件，目前 dew 项目里已经重新实现了 cookie 等部分模块。强烈推荐大家都参与进来，将自己喜欢的，常用的 jQuery 等插件迁移过来。或者推进插件作者直接修改源码，增加对 CommonJS 的支持。路漫漫，但众人拾柴火焰高，星火可燎原，期待大家的参与。&lt;/p&gt;

&lt;p&gt;建议大家直接 fork dew 项目，可以将自己重构的模块 pull request 过来，邮件给 seajs(at)googlegroups.com 群组。讨论和 code review 后，就可以转成 dew 的正式模块。&lt;/p&gt;

&lt;p&gt;等模块丰富起来，我们就可以有更多时间去做更意思的事情了。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>seajs实战参考</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/14/seajs-combat"/>
   <updated>2012-08-14T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/14/seajs-combat</id>
   <content type="html">&lt;h2 id='seajs'&gt;seajs实战参考&lt;/h2&gt;

&lt;p&gt;该页面列举了 SeaJS 中的常用实战过程中的问题。只要掌握这些方法，就可以娴熟地开始对你的网站进行模块化开发了。&lt;/p&gt;

&lt;p&gt;默认情况下，SeaJS 要求所有文件都是标准的 CMD 模块，但现实场景下，有大量 jQuery 插件等非 CMD 模块存在。在 SeaJS 里，通过以下方式，可以直接调用非标准模块。&lt;/p&gt;

&lt;h3 id='js'&gt;全站通用的要加载的库只写一次，而不想每个js里都调用，太繁琐&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//可以放在在 init.js 里暴露到全局，这样，所有在 init.js 之后载入的文件，就都可以直接通过全局变量来拿 $ 等对象。

seajs.use(&amp;#39;init&amp;#39;)

//init.js
define(function(require, exports) {
	var $ = jQuery = require(&amp;#39;jquery&amp;#39;);
	
	// 暴露到全局
	window.$ = $;
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='1__jquery'&gt;1. 暴露 jQuery&lt;/h3&gt;

&lt;p&gt;jQuery 插件都依赖 jQuery 模块，为了加载 jQuery 插件，首先得将 jQuery 模块暴露出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 配置 jquery 并放入预加载项中
seajs.config({
  alias: {
    &amp;#39;jquery&amp;#39;: &amp;#39;https://a.alipayobjects.com/static/arale/jquery/1.7.2/jquery.js&amp;#39;
  },
  preload: [&amp;quot;jquery&amp;quot;]
})

// 将 jQuery 暴露到全局
seajs.modify(&amp;#39;jquery&amp;#39;, function(require, exports) {
  window.jQuery = window.$ = exports
})&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='2__jquery_'&gt;2. 修改 jQuery 插件的接口&lt;/h3&gt;

&lt;p&gt;我们以 jquery.cookie 插件为例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 配置别名
seajs.config({
  alias: {
    &amp;#39;cookie&amp;#39;: &amp;#39;https://raw.github.com/carhartl/jquery-cookie/master/jquery.cookie.js&amp;#39;
  }
})

// 将 jQuery Cookie 插件自动包装成 CMD 接口
seajs.modify(&amp;#39;cookie&amp;#39;, function(require, exports, module) {
  module.exports = $.cookie
})&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='3__cookie_'&gt;3. 调用 Cookie 插件&lt;/h3&gt;

&lt;p&gt;这样，在其他模块中，就可以直接调用 cookie 插件了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a.js:

define(function(require, exports) {
  var cookie = require(&amp;#39;cookie&amp;#39;)

  cookie(&amp;#39;the_cookie&amp;#39;)
  cookie(&amp;#39;the_cookie&amp;#39;, &amp;#39;the_value&amp;#39;)

  // ...
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整范例：&lt;a href='http://seajs.org/test/issues/auto-transport/test.html'&gt;http://seajs.org/test/issues/auto-transport/test.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='seajs'&gt;seajs里版本号和时间戳问题&lt;/h2&gt;

&lt;p&gt;用 seajs 组织项目，上线后，经常需要更新特定文件或所有文件的时间戳，以清空浏览器缓存。最简单的方式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//用来维护 jquery 等类库模块的版本号
seajs.config({
  alias: {
    &amp;#39;jquery&amp;#39;: &amp;#39;jquery/1.6.2/jquery&amp;#39;,
    &amp;#39;backbone&amp;#39;: &amp;#39;backbone/0.5.1/backbone&amp;#39;,
    &amp;#39;a&amp;#39;: &amp;#39;a.js?20110801&amp;#39;,
    &amp;#39;b&amp;#39;: &amp;#39;b.js?20110801&amp;#39;
  }
});	

//利用 map,批量更新时间戳是最方便的
seajs.config({
  &amp;#39;map&amp;#39;: [
    [ /^(.*\.(?:css|js))(.*)$/i, &amp;#39;$1?20110801&amp;#39; ]
  ]
});	&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id3931'&gt;条件加载&lt;/h2&gt;

&lt;p&gt;第一种：把依赖的模块都在 define 头部手工声明，不再依赖 SeaJS 的自动解析功能。这个模块同时依赖 play 和 work 两个模块，加载器会把这两个模块文件都下载下来。如果需要在 require 模块之后串行执行代码，那么只能用这个方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&amp;#39;play&amp;#39;, &amp;#39;work&amp;#39;], function(require, exports) {
	 //是出去玩，还是工作？
    var choice = require(condition() ? &amp;#39;play&amp;#39; : &amp;#39;work&amp;#39;);
	//选择的难度
    console.log(choice.hard());
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种：使用 require.async 来进行条件加载，从静态分析的角度来看，require.async适合需要执行动态加载的模块很大（比如大量 json 数据），不适合都下载下来。但是require.async 方式加载的模块，不能打包工具找到，自然也不能被打包进上线的 js 中；而前一种方式可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
    require.async(condition() ? &amp;#39;play&amp;#39; : &amp;#39;work&amp;#39;, function(choice) {
        console.log(choice.hard());
    });
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id3932'&gt;按需加载&lt;/h2&gt;

&lt;p&gt;很多时候模块并不需要立即加载，等到需要时再加载，性能更好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//init.js
$(&amp;quot;#J_PicCover&amp;quot;).click(function(){
	require.async(&amp;#39;module/highlight&amp;#39;, function(){
		$(&amp;quot;.buy-info&amp;quot;).highlight({color:&amp;#39;#ffe5c4&amp;#39;,speed:500,complete:function(){
		},iterator:&amp;#39;sinusoidal&amp;#39;});
	});
});

//highlight.js
define(function(require, exports) {
	jQuery.fn.highlight = function(settings) {
		//…...
	}
});&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>seajs快速参考</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/13/seajs-cheet-sheet"/>
   <updated>2012-08-13T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/13/seajs-cheet-sheet</id>
   <content type="html">&lt;h2 id='seajs'&gt;seajs快速参考&lt;/h2&gt;

&lt;p&gt;该页面列举了 SeaJS 中的常用 API。只要掌握这些方法，就可以娴熟地进行模块化开发。&lt;/p&gt;

&lt;h3 id='id3924'&gt;启动模块系统&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;http://modules.seajs.org/seajs/1.2.0/sea.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  	seajs.use(&amp;#39;./main&amp;#39;);
	seajs.use([&amp;#39;./a&amp;#39;, &amp;#39;./b&amp;#39;], function(a, b) {
	  a.init();
	  b.init();
	});	  
&amp;lt;/script&amp;gt;

//callback 参数是可选的。当只启动加载一个模块，且不需要 callback 时，可以用 data-main 属性来简化：
&amp;lt;script src=&amp;quot;http://modules.seajs.org/seajs/1.2.0/sea.js&amp;quot; data-main=&amp;quot;./main&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

/*
引入 sea.js 时，可以把 sea.js 与其他文件打包在一起，提前打包好，或利用 combo 服务动态打包。
无论哪一种方式，为了让 sea.js 内部能快速获取到自身路径，推荐手动加上 id 属性：
加上 seajsnode 值，可以让 sea.js 直接获取到自身路径，而不需要通过其他机制去自动获取。
这对性能和稳定性会有一定提升，推荐默认都加上。
*/
&amp;lt;script src=&amp;quot;path/to/sea.js&amp;quot; id=&amp;quot;seajsnode&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='seajsconfig'&gt;seajs.config&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//seajs.config 可以叠加，可以在多处调用，同名 key 覆盖，不同名的 key 叠加。这样可以做到：区域配置可以覆盖通用配置或可以说在区域配置中可对 seajs config 再做按需配置而不会影响到通用配置。
seajs.config({

  //alias最常用来做版本配置与管理，也可以用来做命名空间管理。
  alias: {
    &amp;#39;es5-safe&amp;#39;: &amp;#39;es5-safe/0.9.2/es5-safe&amp;#39;,
    &amp;#39;json&amp;#39;: &amp;#39;json/1.0.1/json&amp;#39;,
    &amp;#39;jquery&amp;#39;: &amp;#39;jquery/1.7.2/jquery&amp;#39;
  },
  
  /*
  使用 preload 配置项，可以在普通模块加载前，提前加载并初始化好指定模块。
  注意：preload 中的配置，需要等到 use 时才加载。
  preload 配置不能放在模块文件里面
  */
  preload: [
    Function.prototype.bind ? &amp;#39;&amp;#39; : &amp;#39;es5-safe&amp;#39;,
    this.JSON ? &amp;#39;&amp;#39; : &amp;#39;json&amp;#39;
  ],
  
  //值为 true 时，加载器会使用 console.log 输出所有错误和调试信息。 默认为 false, 只输出关键信息
  debug: true,
  
  //该配置可将某个文件映射到另一个。可用于在线调试，非常方便。
  map: [
    [&amp;#39;http://example.com/js/app/&amp;#39;, &amp;#39;http://localhost/js/app/&amp;#39;]
  ],
  
  /*
  SeaJS 在解析顶级标识时，会相对 base 路径来解析。
  注意：一般请不要配置 base 路径，保持默认往往最好最方便。
  base 路径的默认值，与 sea.js 的访问路径相关：
  如果 sea.js 的访问路径是：
    http://example.com/js/libs/sea.js
  则 默认base 路径为：
    http://example.com/js/libs/	 
  */ 
  base: &amp;#39;http://example.com/path/to/base/&amp;#39;,
  
  //获取模块文件时，&amp;lt;script&amp;gt; 或 &amp;lt;link&amp;gt; 标签的 charset 属性。 默认是 utf-8 。
  charset: &amp;#39;utf-8&amp;#39;	  
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='seajsuse'&gt;seajs.use&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
模块加载器
seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里。在模块代码里需要异步加载其他模块时，可以使用 require.async 方法。
*/

seajs.use(&amp;#39;./a&amp;#39;);

seajs.use(&amp;#39;./a&amp;#39;, function(a) {
  a.doSomething();
});

seajs.use([&amp;#39;./a&amp;#39;, &amp;#39;./b&amp;#39;], function(a, b) {
  a.doSomething();
  b.doSomething();
});

//seajs.use 与 dom ready 事件没有任何关系。
//如果某些操作要确保在 dom ready 后执行，需要自己使用 jquery 等类库来保证
seajs.use([&amp;#39;jquery&amp;#39;, &amp;#39;page&amp;#39;], function($, page) {
  $(function() {
    page.init()
  })
})	&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='define'&gt;define&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
CMD 模块定义 define(factory);
define 是全局函数，用来定义模块。
在开发时，define 仅接收一个 factory 参数。
factory 可以是一个函数，也可以是对象、字符串等类型。
factory 为对象、字符串等非函数类型时，表示模块的接口就是该对象、字符串等值。
factory 为函数时，表示模块的构造方法。执行该方法，可以得到模块向外提供的接口。
*/
define(function(require, exports, module) {

  // The module code goes here

});

/*
模块代码需要用 define 回调包起来：id 与 dependencies 参数是可以省略的
id 用来显式指定模块 ID。当你的项目上线，所有的模块都合并到了一个文件中，如果不显示指定， SeaJS 就无从知道哪个模块是哪个了。在开发的时候，一般用不到它。
dependencies 也是如此。它列出了当前模块所依赖的模块，在开发的时候是不需要写明的。 SeaJS 会检查你的模块回调函数，找到所有的 require 语句，从而得到你的模块的所有依赖。 在真正 require 当前模块时，会先去请求这个模块的依赖，加载完毕，再去初始化当前的模块。
*/
define(id, dependencies, function(require, exports, module) {
    // module code.
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='require'&gt;require&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
require 是一个方法，用来获取其他模块提供的接口。
require 接受 模块标识 作为唯一参数

模块依赖解析，靠的是三个重要的规则：
	不能重命名 require
	不能覆盖 require
	require 的参数必须是字符串字面量，不可以 require(foo()) 或者 require(bar)， 也不可以是 require(should_be_a ? &amp;#39;a&amp;#39; : &amp;#39;b&amp;#39;)。	参数值必须是字符串直接量,如 require(&amp;quot;my-module&amp;quot;);
	核心原因是因为在浏览器端，文件的读取是异步的，依赖信息要提前获取，不能在运行时才确定。在服务器端，文件读取是同步的，因此可以是变量。
*/
define(function(require) {
  var a = require(&amp;#39;./a&amp;#39;);
  a.doSomething();
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='requireasync'&gt;require.async&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
require.async(id, callback)
async 方法可用来异步加载模块，并在加载完成后执行指定回调。
*/
define(function(require, exports, module) {
  // load one module
  require.async(&amp;#39;./b&amp;#39;, function(b) {
    b.doSomething();
  });

  // load multiple modules
  require.async([&amp;#39;./c&amp;#39;, &amp;#39;./d&amp;#39;], function(c, d) {
    // do something
  });
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='requireresolve'&gt;require.resolve&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
require.resolve(id)
使用模块系统内部的路径解析机制来解析并返回模块路径。该函数不会加载模块，只返回解析后的绝对路径。
*/
define(function(require, exports) {
  console.log(require.resolve(&amp;#39;./b&amp;#39;)); 
  // ==&amp;gt; &amp;#39;http://example.com/js/b.js&amp;#39;
});	&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='exports'&gt;exports&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
exports 是一个对象，用来向外提供模块接口。
exports 仅仅是 module.exports 的一个引用。
在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。
因此给 exports 赋值是无效的，不能用来更改模块接口，正确的写法是用 return 或者给 module.exports 赋值。
exports = {}是错误的，module.exports ={}才是正确的写法。
*/

define(function(require, exports) {
  // snip...
  exports.foo = &amp;#39;bar&amp;#39;;
  exports.doSomething = function() {};
});
module.exports

define(function(require, exports, module) {
  // snip...
  module.exports = {
    name: &amp;#39;a&amp;#39;,
    doSomething: function() {};
  };
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='module'&gt;module&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。
*/
define(function(require, exports, module) {

	//module.id 模块标识。require(module.id) 必然返回此模块的 exports 。
   console.log(require(module.id) === exports); // true
   
   //module.uri根据模块系统的路径解析规则得到的模块绝对路径。
   console.log(module.uri); // http://example.com/path/to/this/file.js
   
   //module.dependencies dependencies 是一个数组，表示当前模块的依赖列表。
   
   /*
   module.exports 当前模块对外提供的接口。
   module.exports 的赋值需要同步执行，不能放在回调函数里
   */
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上接口是最常用的，要牢记于心。&lt;/p&gt;

&lt;h3 id='id3925'&gt;可写成如下&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;seajs.config({
  alias: {
    &amp;#39;jquery&amp;#39;: &amp;#39;http://modules.seajs.org/jquery/1.7.2/jquery.js&amp;#39;
  }
});

define(&amp;#39;hi&amp;#39;, function(require, exports) {
    exports.sayHi = function() {
        alert(&amp;#39;hi&amp;#39;)
    } 
})

seajs.use([&amp;#39;jquery&amp;#39;, &amp;#39;hi&amp;#39;], function($, h) {
    $(&amp;#39;#beautiful-sea&amp;#39;).click(h.sayHi)
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='js'&gt;模块化后的js写法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) = {
 
    //原jquery.js代码...
 
    module.exports = $.noConflict(true);
});
 
//init.js
define(function(require, exports, module) = {
    var $ = require(&amp;#39;jquery&amp;#39;);
    var m1 = require(&amp;#39;module1&amp;#39;);
     
    exports.initPage = function() {
        $(&amp;#39;.content&amp;#39;).html(m1.run());    
    }
});
 
//module1.js
define(function(require, exports, module) = {
    var $ = require(&amp;#39;jquery&amp;#39;);
    var m2 = require(&amp;#39;module2&amp;#39;);
    var m3 = require(&amp;#39;module3&amp;#39;);
     
    exports.run = function() {
        return $.merge([&amp;#39;module1&amp;#39;], $.merge(m2.run(), m3.run()));    
    }
});
 
//module2.js
define(function(require, exports, module) = {
    exports.run = function() {
        return [&amp;#39;module2&amp;#39;];
    }
});
 
//module3.js
define(function(require, exports, module) = {
    var $ = require(&amp;#39;jquery&amp;#39;);
    var m4 = require(&amp;#39;module4&amp;#39;);
     
    exports.run = function() {
        return $.merge([&amp;#39;module3&amp;#39;], m4.run());    
    }
});
 
//module4.js
define(function(require, exports, module) = {
    exports.run = function() {
        return [&amp;#39;module4&amp;#39;];
    }
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id3926'&gt;实际使用中&lt;/h2&gt;

&lt;p&gt;在工程内使用seajs，以前引用的插件、模块也都要用define的语法重新进行封装，比较麻烦，老代码可以不修改，继续使用就好。但强烈建立花点时间都修改成 CMD 模块，这样对以后的维护，以及页面性能很有好处。不然以后修改起来估计会更麻烦。&lt;/p&gt;

&lt;p&gt;其实可以混用的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;underscore.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;backbone.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script src=&amp;quot;sea.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，常用的 jquery 等类库，依旧是传统的用法，用全局变量引用就好，通过同步引入的方式，也不会有依赖顺序问题。 自己的代码，都按照 CMD 规范写成模块的形式。&lt;/p&gt;

&lt;p&gt;其实上面的方式挺好的，特别对于要兼容老代码的情况的。 推荐还是都彻底模块化，看起来要多写一些 require，但值得，因为这样可以让每个模块自身的信息完整，从而减少对 环境的依赖，对后续的可维护性很好益处。&lt;/p&gt;

&lt;h2 id='seajsapi'&gt;seajs官方api&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://seajs.org/docs/#api'&gt;详细官方文档&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/240'&gt;模块系统&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/242'&gt;CMD 模块定义规范&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/258'&gt;模块标识&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/259'&gt;require 书写约定&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/260'&gt;模块加载器&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/262'&gt;配置&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/265'&gt;常用插件&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/281'&gt;打包部署&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/266'&gt;快速参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='id3927'&gt;第三方库&lt;/h2&gt;

&lt;p&gt;SeaJS 提供了一个类似于npm的管理工具，里面有他们改造好的第三方库，你可以在这里找找是否有适合的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;spm Git Pero: &lt;a href='https://github.com/seajs/spm'&gt;https://github.com/seajs/spm&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;spm module list: &lt;a href='http://seajs.cloudfoundry.com/'&gt;http://seajs.cloudfoundry.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='seajs_blog_'&gt;seajs blog 等文档&lt;/h2&gt;

&lt;h3 id='id3928'&gt;初级入门&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://www.cnblogs.com/leoo2sk/archive/2011/06/27/write-javascript-with-seajs.html'&gt;使用 SeaJS 实现模块化 JavaScript 开发&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://clonn.blogspot.com/2011/05/seajs-nonblocking-require-library.html'&gt;SeaJS, 模組化開發加載套件&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.infoq.com/cn/news/2011/05/nodeparty-hangzhou'&gt;NodeParty 杭州站会议纪实：Jscex, SeaJS 与 MyFOX&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/14/seajs-and-nodejs/'&gt;SeaJS – 跨环境模块化开发实践 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://ghsky.com/2011/05/seajs-first-view.html'&gt;初识 SeaJS&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/04/26/intro-to-seajs/'&gt;SeaJS – 不仅仅是脚本加载器 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.infoq.com/cn/presentations/hjp-infoq-salon'&gt;去哪儿网的 JavaScript 模块化之路&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/04/05/seajs-080-released/'&gt;海纳百川、有容乃大 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id3929'&gt;中级使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://cyj.me/why-seajs/zh/'&gt;seajs所为何-逸才&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/08/10/extending-built-in-native-objects/'&gt;扩展原生对象与 es5-safe 模块 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/08/01/best-practice-of-version-management/'&gt;SeaJS 里版本号和时间戳管理的最佳实践&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/07/24/online-local-debug/'&gt;在线本地调试大观 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.cnblogs.com/leoo2sk/archive/2011/07/01/temod-intro.html'&gt;在 SeaJS 中实现 html 模板文件的加载（Temod 介绍）&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://blog.163.com/jinlu_hz/blog/static/113830152201142011225195/'&gt;在 SeaJS 里使用 LABjs&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/26/exports-and-module-load-in-seajs/'&gt;SeaJS 中的 exports 和模块加载 -玉伯&lt;/a&gt;-墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/18/jquery-plugins-modulization/'&gt;jQuery 插件的模块化 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/02/seajs-css-support/'&gt;SeaJS – 对 CSS 模块的支持 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/286'&gt;直接调用 jQuery 插件等非标准模块的方法&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/08/19/jquery-introduction-and-plugins-modulization/'&gt;jQuery 模块介绍与 jQuery 插件的深度模块化 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.heiniuhaha.com/file/sea-zh.js'&gt;seajs中文版源码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id3930'&gt;高级探索&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://hax.iteye.com/blog/1146699'&gt;shim是应该抛异常还是应该fail silently？-hax&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://limu.iteye.com/blog/1136712'&gt;扩展 SeaJS 模块定义中的 module 参数的应用示例 -李牧&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/17/the-difference-between-seajs-and-requirejs/'&gt;SeaJS 和 RequireJS 的异同 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>使用github+jekyll搭建blog环境，完美替代wordpress</title>
   <link href="http://heiniuhaha.github.com/lessons/2012/08/09/use-jekyll-build-blog"/>
   <updated>2012-08-09T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2012/08/09/use-jekyll-build-blog</id>
   <content type="html">&lt;p&gt;也来讲讲怎么使用github pages做blog环境&lt;/p&gt;

&lt;h2 id='id3917'&gt;优点&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;空间免费，github托管，稳定又安全，遭遇过空间商跑路的朋友是不是想起伤心往事；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;允许本地服务器调试，脱离网络写文章毫无压力，因为可以使用git命令同步来管理文章，版本控制妥妥的，对技术人员来说，一键恢复，实在是神物；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;还能绑定顶级域名，亲，人家免费空间竟然还允许我们绑域名有木有~~；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;文章用markedown编写，以前遭受排版困扰的亲们是不是很激动；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id='id3918'&gt;购买域名&lt;/h2&gt;

&lt;p&gt;可以去&lt;a href='http://www.net.cn'&gt;万网&lt;/a&gt;，这两天正好在促销. &lt;img alt='net-cn-sales' src='/assets/themes/twitter/pic/net-cn-sales.png' /&gt;&lt;/p&gt;

&lt;h2 id='dnspod'&gt;用免费的dnsPod做域名解析&lt;/h2&gt;

&lt;p&gt;dnspod链接地址&lt;a href='https://www.dnspod.cn/'&gt;https://www.dnspod.cn/&lt;/a&gt; &lt;img alt='dnspod settings' src='/assets/themes/twitter/pic/dnspod-setting.png' /&gt;&lt;/p&gt;

&lt;h2 id='githubjekyll'&gt;github注册和本地电脑jekyll等环境配置&lt;/h2&gt;

&lt;p&gt;参考最底下的参考文章，省略。。。&lt;/p&gt;

&lt;h2 id='id3919'&gt;命令&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;h3 id='git'&gt;git命令获取远程文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='id3920'&gt;定位到目录&lt;code&gt;heiniu.github.com&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd .ssh/heiniuhaha.github.com&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='id3921'&gt;使用&lt;code&gt;rake&lt;/code&gt;命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;rake page           # Create a new page.
rake post           # Begin a new post in ./_posts
rake preview        # Launch preview environment&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='markdown'&gt;写文章的时候学习下&lt;a href='https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md'&gt;markdown语法&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;如:中文单引号 &amp;#96; 用来标注小块代码,如&lt;code&gt;github&lt;/code&gt; &lt;code&gt;jekyll&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='git'&gt;最后提交git代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git add .
git commit . -m &amp;#39;just another commit&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='id3922'&gt;日常发布完整命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git//本地如果无远程代码，先做这步，不然就忽略
cd .ssh/heiniuhaha.github.com//定位到你blog的目录下
git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件
git status //查看本地自己修改了多少文件
git add .//添加远程不存在的git文件
git commit * -m &amp;quot;what I want told to someone&amp;quot;
git push origin master //更新到远程服务器上&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id3923'&gt;参考文章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html'&gt;搭建一个免费的，无限流量的Blog&amp;#8212;-github Pages和Jekyll入门&lt;/a&gt; 阮一峰写于2012-08-25 【推荐】&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://beiyuu.com/github-pages/'&gt;使用Github Pages建独立博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://blog.leezhong.com/tech/2010/08/25/make-github-as-blog-engine.html'&gt;使用github作为博客引擎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://jekyllbootstrap.com/'&gt;The Quickest Way to Blog with Jekyll.&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='git_api_'&gt;附件：git api 总结图&lt;/h2&gt;

&lt;p&gt;链接：&lt;a href='/assets/themes/twitter/pic/git-api.png'&gt;http://www.heiniuhaha.com/assets/themes/twitter/pic/git-api.png&lt;/a&gt; &lt;img alt='git api 总结图' src='/assets/themes/twitter/pic/git-api.png' /&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Use Google Code Prettify</title>
   <link href="http://heiniuhaha.github.com/lessons/2012/08/09/use-google-code-prettify"/>
   <updated>2012-08-09T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2012/08/09/use-google-code-prettify</id>
   <content type="html">&lt;h2 id='jekyll_googlecodeprettify'&gt;jekyll中代码高亮 google-code-prettify&lt;/h2&gt;

&lt;p&gt;看了jekyll的代码高亮插件pygments,觉得配置太复杂,就用了轻量级的google-code-prettify,使用非常方便.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先下载用于高亮代码的文件包,点击&lt;a href='http://code.google.com/p/google-code-prettify/downloads/list'&gt;google-code-prettify下载地址&lt;/a&gt;下载small版本的代码.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;复制进相应的目录,找到default.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Users/heiniu/.ssh/heiniuhaha.github.com/_includes/themes/default.html&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;打开default.html,在最后面添加相应的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/code/prettify.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/jquery-1.8.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  $(function(){
    $(&amp;quot;pre&amp;quot;).addClass(&amp;quot;prettyprint linenums&amp;quot;);
    prettyPrint();
    $(&amp;#39;.entry a&amp;#39;).each(function(){
      if($(this).attr(&amp;quot;href&amp;quot;).indexOf(&amp;quot;heiniuhaha&amp;quot;) == -1){
        $(this).attr(&amp;quot;target&amp;quot;, &amp;quot;_blank&amp;quot;);
      }
    })
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>My Github First Blog</title>
   <link href="http://heiniuhaha.github.com/lessons/2012/08/07/my-github-first-blog"/>
   <updated>2012-08-07T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2012/08/07/my-github-first-blog</id>
   <content type="html">&lt;h2 id='themes'&gt;应用themes发现的问题&lt;/h2&gt;

&lt;p&gt;我尝试了the-program的theme,但是出现一个使用iframe的警告,看了源文件,没有发现可修复的地方,直接放弃这个theme吧.&lt;/p&gt;

&lt;p&gt;&lt;img alt='theme iframe waring' src='/assets/themes/twitter/img/theme-iframe.png' /&gt;&lt;/p&gt;

&lt;h4 id='code'&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;For security reasons,framing is not allowed.
	
&amp;lt;iframe src=&amp;quot;http://markdotto.github.com/github-buttons/github-btn.html?user=plusjade&amp;amp;repo=jekyll-bootstrap&amp;amp;type=fork&amp;amp;count=true&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我只能换成twitter皮肤,我想这个皮肤应该是最稳定的了.等使用熟练后再改成自己的皮肤.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>怎么让一个js文件只有是ie6的时候才加载</title>
   <link href="http://heiniuhaha.github.com/ie/2012/08/05/just-ie6-loadjs"/>
   <updated>2012-08-05T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/ie/2012/08/05/just-ie6-loadjs</id>
   <content type="html">&lt;p&gt;有朋友问怎么让一个js文件只有是ie6的时候才加载，特记录下:&lt;/p&gt;

&lt;h3 id='id3913'&gt;方式一：利用&lt;code&gt;[if IE 6]&lt;/code&gt;的判断方式&lt;/h3&gt;

&lt;h4 id='code'&gt;code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--[if IE 6]&amp;gt;	&amp;lt;script src=&amp;quot;http://yourdomain.com/script.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;	&amp;lt;![endif]--&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点：简洁直观&lt;/p&gt;

&lt;p&gt;缺点：阻塞加载&lt;/p&gt;

&lt;h4 id='id3914'&gt;&lt;code&gt;[if IE]&lt;/code&gt;的浏览器判断&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1. &amp;lt;!--[if !IE]&amp;gt;除IE外都可识别 &amp;lt;![endif]--&amp;gt;
2. &amp;lt;!--[if IE]&amp;gt; 所有的IE可识别 &amp;lt;![endif]--&amp;gt;
3. &amp;lt;!--[if IE 5.0]&amp;gt; 只有IE5.0可以识别 &amp;lt;![endif]--&amp;gt; 
4. &amp;lt;!--[if IE 5]&amp;gt; 仅IE5.0与IE5.5可以识别 &amp;lt;![endif]--&amp;gt;
5. &amp;lt;!--[if gt IE 5.0]&amp;gt; IE5.0以及IE5.0以上版本都可以识别 &amp;lt;![endif]--&amp;gt;
6. &amp;lt;!--[if IE 6]&amp;gt; 仅IE6可识别 &amp;lt;![endif]--&amp;gt;
7. &amp;lt;!--[if lt IE 6]&amp;gt; IE6以及IE6以下版本可识别 &amp;lt;![endif]--&amp;gt;
8. &amp;lt;!--[if gte IE 6]&amp;gt; IE6以及IE6以上版本可识别 &amp;lt;![endif]--&amp;gt;
9. &amp;lt;!--[if IE 7]&amp;gt; 仅IE7可识别 &amp;lt;![endif]--&amp;gt;
10. &amp;lt;!--[if lt IE 7]&amp;gt; IE7以及IE7以下版本可识别 &amp;lt;![endif]--&amp;gt;
11. &amp;lt;!--[if gte IE 7]&amp;gt; IE7以及IE7以上版本可识别 &amp;lt;![endif]--&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按原意是&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;lt&lt;/code&gt;：less than 当前指定版本以下，不包含当前版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;gt&lt;/code&gt;：greater than 当前指定版本以上，不包含当前版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;lte&lt;/code&gt;：less than or equal 当前指定版本以下，包含当前版本(等于)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;gte&lt;/code&gt;：greater than or equal 当前指定版本以上，包含当前版本(等于)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id='js'&gt;方式二：js判断浏览器版本再异步加载&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;(function() {
	 var isIE6= navigator.appVersion.indexOf(&amp;quot;MSIE 6&amp;quot;)&amp;gt;-1;
	 if(isIE6){
	     var s = document.createElement(&amp;#39;script&amp;#39;);
	     s.type = &amp;#39;text/javascript&amp;#39;;
	     s.async = true;
	     s.src = &amp;#39;http://yourdomain.com/script.js&amp;#39;;
	     var x = document.getElementsByTagName(&amp;#39;script&amp;#39;)[0];
	     x.parentNode.insertBefore(s, x);
	 }
 })();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点：适合于有洁癖的开发者，或是希望异步无阻塞加载。&lt;/p&gt;

&lt;p&gt;缺点：代码量多，执行js效率差，如果是需要立即执行渲染的程序，此方式不适合。&lt;/p&gt;

&lt;h3 id='id3915'&gt;两种方式性能评测&lt;/h3&gt;

&lt;h3 id='id3916'&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://msdn2.microsoft.com/en-us/library/ms537512.aspx'&gt;MSDN&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://han.guokai.blog.163.com/blog/static/1367182712011115105841181/'&gt;异步加载详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>ECMAScript5初探</title>
   <link href="http://heiniuhaha.github.com/javascript/2012/08/05/ECMAScript5"/>
   <updated>2012-08-05T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/javascript/2012/08/05/ECMAScript5</id>
   <content type="html">&lt;p&gt;Javascript是一个类C的语言，他的面向对象的东西相对于C++/Java比较奇怪，但是其的确相当的强大，在 &lt;a href='http://www.
cnblogs.com/weidagang2046/'&gt;Todd 同学&lt;/a&gt;的“&lt;a href='http://coolshell.cn/articles/5202.html'&gt;对象的消息模型&lt;/a&gt; ”一文中我们已经可以看到一些端倪了。这两天有个前同事总在问我Javascript面向对象的东西，所以，索性写篇文章让他看去吧，这里这篇文章主要想从一个整体的 角度来说明一下Javascript的面向对象的编程。（&lt;strong&gt;成文比较仓促，应该有不准确或是有误的地方，请大家批评指正&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;另，这篇文章主要基于 &lt;a href='http://www.ecma-
international.org/publications/standards/Ecma-262.htm'&gt;ECMAScript 5&lt;/a&gt;， 旨在介绍新技术。关于兼容性的东西，请看最后一节。&lt;/p&gt;

&lt;h4 id='id3908'&gt;初探&lt;/h4&gt;

&lt;p&gt;我们知道Javascript中的变量定义基本如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var name = &amp;#39;Chen Hao&amp;#39;;;
var email = &amp;#39;haoel(@)hotmail.com&amp;#39;;
var website = &amp;#39;http://coolshell.cn&amp;#39;;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要用对象来写的话，就是下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var chenhao = {
    name :&amp;#39;Chen Hao&amp;#39;,
    email : &amp;#39;haoel(@)hotmail.com&amp;#39;,
    website : &amp;#39;http://coolshell.cn&amp;#39;
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，我就可以这样访问：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//以成员的方式
chenhao.name;
chenhao.email;
chenhao.website;

//以hash map的方式
chenhao[&amp;quot;name&amp;quot;];
chenhao[&amp;quot;email&amp;quot;];
chenhao[&amp;quot;website&amp;quot;];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于函数，我们知道Javascript的函数是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var doSomething = function(){
   alert(&amp;#39;Hello World.&amp;#39;);
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，我们可以这么干：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var sayHello = function(){
   var hello = &amp;quot;Hello, I&amp;#39;m &amp;quot;+ this.name
                + &amp;quot;, my email is: &amp;quot; + this.email
                + &amp;quot;, my website is: &amp;quot; + this.website;
   alert(hello);
};

//直接赋值，这里很像C/C++的函数指针
chenhao.Hello = sayHello;

chenhao.Hello();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信这些东西都比较简单，大家都明白了。 可以看到javascript对象函数是直接声明，直接赋值，直接就用了。runtime的动态语言。&lt;/p&gt;

&lt;p&gt;还有一种比较规范的写法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//我们可以看到， 其用function来做class。
var Person = function(name, email, website){
    this.name = name;
    this.email = email;
    this.website = website;

    this.sayHello = function(){
        var hello = &amp;quot;Hello, I&amp;#39;m &amp;quot;+ this.name  + &amp;quot;, \n&amp;quot; +
                    &amp;quot;my email is: &amp;quot; + this.email + &amp;quot;, \n&amp;quot; +
                    &amp;quot;my website is: &amp;quot; + this.website;
        alert(hello);
    };
};

var chenhao = new Person(&amp;quot;Chen Hao&amp;quot;, &amp;quot;haoel@hotmail.com&amp;quot;,
                                     &amp;quot;http://coolshell.cn&amp;quot;);
chenhao.sayHello(); &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便说一下，要删除对象的属性，很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;delete chenhao[&amp;#39;email&amp;#39;]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的这些例子，我们可以看到这样几点：&lt;/p&gt;

&lt;p&gt;1. Javascript的数据和成员封装很简单。没有类完全是对象操作。纯动态！ 2. Javascript function中的this指针很关键，如果没有的话，那就是局部变量或局部函数。 3. Javascript对象成员函数可以在使用时临时声明，并把一个全局函数直接赋过去就好了。 4. Javascript的成员函数可以在实例上进行修改，也就是说不同实例相同函数名的行为不一定一样。&lt;/p&gt;

&lt;h4 id='__objectdefineproperty'&gt;属性配置 - Object.defineProperty&lt;/h4&gt;

&lt;p&gt;先看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//创建对象
var chenhao = Object.create(null);

//设置一个属性
 Object.defineProperty( chenhao,
                &amp;#39;name&amp;#39;, { value:  &amp;#39;Chen Hao&amp;#39;,
                          writable:     true,
                          configurable: true,
                          enumerable:   true });

//设置多个属性
Object.defineProperties( chenhao,
    {
        &amp;#39;email&amp;#39;  : { value:  &amp;#39;haoel@hotmail.com&amp;#39;,
                     writable:     true,
                     configurable: true,
                     enumerable:   true },
        &amp;#39;website&amp;#39;: { value: &amp;#39;http://coolshell.cn&amp;#39;,
                     writable:     true,
                     configurable: true,
                     enumerable:   true }
    }
);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面就说说这些属性配置是什么意思。&lt;/p&gt;

&lt;p&gt;* writable：这个属性的值是否可以改。 * configurable：这个属性的配置是否可以改。 * enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。 * value：属性值。 * get()/set(_value)：get和set访问器。&lt;/p&gt;

&lt;h4 id='getset_'&gt;Get/Set 访问器&lt;/h4&gt;

&lt;p&gt;关于get/set访问器，它的意思就是用get/set来取代value（其不能和value一起使用），示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var  age = 0;
Object.defineProperty( chenhao,
            &amp;#39;age&amp;#39;, {
                      get: function() {return age+1;},
                      set: function(value) {age = value;}
                      enumerable : true,
                      configurable : true
                    }
);
chenhao.age = 100; //调用set
alert(chenhao.age); //调用get 输出101（get中+1了）;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再看一个更为实用的例子——利用已有的属性(age)通过get和set构造新的属性(birth_year)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.defineProperty( chenhao,
            &amp;#39;birth_year&amp;#39;,
            {
                get: function() {
                    var d = new Date();
                    var y = d.getFullYear();
                    return ( y - this.age );
                },
                set: function(year) {
                    var d = new Date();
                    var y = d.getFullYear();
                    this.age = y - year;
                }
            }
);

alert(chenhao.birth_year);
chenhao.birth_year = 2000;
alert(chenhao.age);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做好像有点麻烦，你说，我为什么不写成下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var chenhao = {
    name: &amp;quot;Chen Hao&amp;quot;,
    email: &amp;quot;haoel@hotmail.com&amp;quot;,
    website: &amp;quot;http://coolshell.cn&amp;quot;,
    age: 100,
    get birth_year() {
        var d = new Date();
        var y = d.getFullYear();
        return ( y - this.age );
    },
    set birth_year(year) {
        var d = new Date();
        var y = d.getFullYear();
        this.age = y - year;
    }

};
alert(chenhao.birth_year);
chenhao.birth_year = 2000;
alert(chenhao.age);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，你的确可以这样的，不过通过defineProperty()你可以干这些事：&lt;/p&gt;

&lt;p&gt;1）设置如 writable，configurable，enumerable 等这类的属性配置。&lt;/p&gt;

&lt;p&gt;2）动态地为一个对象加属性。比如：一些HTML的DOM对像。&lt;/p&gt;

&lt;h4 id='id3909'&gt;查看对象属性配置&lt;/h4&gt;

&lt;p&gt;如果查看并管理对象的这些配置，下面有个程序可以输出对象的属性和配置等东西：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//列出对象的属性.
function listProperties(obj)
{
    var newLine = &amp;quot;  
&amp;quot;;
    var names = Object.getOwnPropertyNames(obj);
    for (var i = 0; i &amp;lt; names.length; i++) {
        var prop = names[i];
        document.write(prop + newLine);

        // 列出对象的属性配置（descriptor）动用getOwnPropertyDescriptor函数。
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        for (var attr in descriptor) {
            document.write(&amp;quot;...&amp;quot; + attr + &amp;#39;: &amp;#39; + descriptor[attr]);
            document.write(newLine);
        }
        document.write(newLine);
    }
}

listProperties(chenhao);&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='callapply_bind__this'&gt;call，apply， bind 和 this&lt;/h4&gt;

&lt;p&gt;关于Javascript的this指针，和C++/Java很类似。 我们来看个示例：（这个示例很简单了，我就不多说了）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function print(text){
    document.write(this.value + &amp;#39; - &amp;#39; + text+ &amp;#39;  
&amp;#39;);
}

var a = {value: 10, print : print};
var b = {value: 20, print : print};

print(&amp;#39;hello&amp;#39;);// this =&amp;gt; global, output &amp;quot;undefined - hello&amp;quot;

a.print(&amp;#39;a&amp;#39;);// this =&amp;gt; a, output &amp;quot;10 - a&amp;quot;
b.print(&amp;#39;b&amp;#39;); // this =&amp;gt; b, output &amp;quot;20 - b&amp;quot;

a[&amp;#39;print&amp;#39;](&amp;#39;a&amp;#39;); // this =&amp;gt; a, output &amp;quot;10 - a&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再来看看call 和 apply，这两个函数的差别就是参数的样子不一样，另一个就是性能不一样，apply的性能要差很多。（关于性能，可到 &lt;a href='http://jsperf.com/'&gt;JSPerf&lt;/a&gt; 上去跑跑看看）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print.call(a, &amp;#39;a&amp;#39;); // this =&amp;gt; a, output &amp;quot;10 - a&amp;quot;
print.call(b, &amp;#39;b&amp;#39;); // this =&amp;gt; b, output &amp;quot;20 - b&amp;quot;

print.apply(a, [&amp;#39;a&amp;#39;]); // this =&amp;gt; a, output &amp;quot;10 - a&amp;quot;
print.apply(b, [&amp;#39;b&amp;#39;]); // this =&amp;gt; b, output &amp;quot;20 - b&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在bind后，this指针，可能会有不一样，但是因为Javascript是动态的。如下面的示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var p = print.bind(a);
p(&amp;#39;a&amp;#39;);             // this =&amp;gt; a, output &amp;quot;10 - a&amp;quot;
p.call(b, &amp;#39;b&amp;#39;);     // this =&amp;gt; a, output &amp;quot;10 - b&amp;quot;
p.apply(b, [&amp;#39;b&amp;#39;]);  // this =&amp;gt; a, output &amp;quot;10 - b&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='__'&gt;继承 和 重载&lt;/h4&gt;

&lt;p&gt;通过上面的那些示例，我们可以通过Object.create()来实际继承，请看下面的代码，Student继承于Object。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = Object.create(null);

Object.defineProperties
(
    Person,
    {
        &amp;#39;name&amp;#39;  : {  value: &amp;#39;Chen Hao&amp;#39;},
        &amp;#39;email&amp;#39;  : { value : &amp;#39;haoel@hotmail.com&amp;#39;},
        &amp;#39;website&amp;#39;: { value: &amp;#39;http://coolshell.cn&amp;#39;}
    }
);

Person.sayHello = function () {
    var hello = &amp;quot;

Hello, I am &amp;quot;+ this.name  + &amp;quot;,   
&amp;quot; +
                &amp;quot;my email is: &amp;quot; + this.email + &amp;quot;,   
&amp;quot; +
                &amp;quot;my website is: &amp;quot; + this.website;
    document.write(hello + &amp;quot;  
&amp;quot;);
}

var Student = Object.create(Person);
Student.no = &amp;quot;1234567&amp;quot;; //学号
Student.dept = &amp;quot;Computer Science&amp;quot;; //系

//使用Person的属性
document.write(Student.name + &amp;#39; &amp;#39; + Student.email + &amp;#39; &amp;#39; + Student.website +&amp;#39;  
&amp;#39;);

//使用Person的方法
Student.sayHello();

//重载SayHello方法
Student.sayHello = function (person) {
    var hello = &amp;quot;

Hello, I am &amp;quot;+ this.name  + &amp;quot;,   
&amp;quot; +
                &amp;quot;my email is: &amp;quot; + this.email + &amp;quot;,   
&amp;quot; +
                &amp;quot;my website is: &amp;quot; + this.website + &amp;quot;,   
&amp;quot; +
                &amp;quot;my student no is: &amp;quot; + this. no + &amp;quot;,   
&amp;quot; +
                &amp;quot;my departent is: &amp;quot; + this. dept;
    document.write(hello + &amp;#39;  
&amp;#39;);
}
//再次调用
Student.sayHello();

//查看Student的属性（只有 no 、 dept 和 重载了的sayHello）
document.write(&amp;#39;

&amp;#39; + Object.keys(Student) + &amp;#39;  
&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通用上面这个示例，我们可以看到，Person里的属性并没有被真正复制到了Student中来，但是我们可以去存取。这是因为Javascript用委托实现了这一 机制。其实，这就是Prototype，Person是Student的Prototype。&lt;/p&gt;

&lt;p&gt;当我们的代码需要一个属性的时候，Javascript的引擎会先看当前的这个对象中是否有这个属性，如果没有的话，就会查找他的Prototype对象是否有这个属 性，一直继续下去，直到找到或是直到没有Prototype对象。&lt;/p&gt;

&lt;p&gt;为了证明这个事，我们可以使用Object.getPrototypeOf()来检验一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Student.name = &amp;#39;aaa&amp;#39;;

//输出 aaa
document.write(&amp;#39;

&amp;#39; + Student.name + &amp;#39;

&amp;#39;);

//输出 Chen Hao
document.write(&amp;#39;

&amp;#39; +Object.getPrototypeOf(Student).name + &amp;#39;

&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，你还可以在子对象的函数里调用父对象的函数，就好像C++里的 Base::func() 一样。于是，我们重载hello的方法就可以使用父类的代码了，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//新版的重载SayHello方法
Student.sayHello = function (person) {
    Object.getPrototypeOf(this).sayHello.call(this);
    var hello = &amp;quot;my student no is: &amp;quot; + this. no + &amp;quot;,   
&amp;quot; +
                &amp;quot;my departent is: &amp;quot; + this. dept;
    document.write(hello + &amp;#39;  
&amp;#39;);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个很强大吧。&lt;/p&gt;

&lt;h4 id='id3910'&gt;组合&lt;/h4&gt;

&lt;p&gt;上面的那个东西还不能满足我们的要求，我们可能希望这些对象能真正的组合起来。为什么要组合？因为我们都知道是这是OO设计的最重要的东西。不过，这对于Javasc ript来并没有支持得特别好，不好我们依然可以搞定个事。&lt;/p&gt;

&lt;p&gt;首先，我们需要定义一个Composition的函数：（target是作用于是对象，source是源对象），下面这个代码还是很简单的，就是把source里的属 性一个一个拿出来然后定义到target中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Composition(target, source)
{
    var desc  = Object.getOwnPropertyDescriptor;
    var prop  = Object.getOwnPropertyNames;
    var def_prop = Object.defineProperty;

    prop(source).forEach(
        function(key) {
            def_prop(target, key, desc(source, key))
        }
    )
    return target;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个函数以后，我们就可以这来玩了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//艺术家
var Artist = Object.create(null);
Artist.sing = function() {
    return this.name + &amp;#39; starts singing...&amp;#39;;
}
Artist.paint = function() {
    return this.name + &amp;#39; starts painting...&amp;#39;;
}

//运动员
var Sporter = Object.create(null);
Sporter.run = function() {
    return this.name + &amp;#39; starts running...&amp;#39;;
}
Sporter.swim = function() {
    return this.name + &amp;#39; starts swimming...&amp;#39;;
}

Composition(Person, Artist);
document.write(Person.sing() + &amp;#39;  
&amp;#39;);
document.write(Person.paint() + &amp;#39;  
&amp;#39;);

Composition(Person, Sporter);
document.write(Person.run() + &amp;#39;  
&amp;#39;);
document.write(Person.swim() + &amp;#39;  
&amp;#39;);

//看看 Person中有什么？（输出：sayHello,sing,paint,swim,run）
document.write(&amp;#39;

&amp;#39; + Object.keys(Person) + &amp;#39;  
&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='prototype__'&gt;Prototype 和 继承&lt;/h4&gt;

&lt;p&gt;我们先来说说Prototype。我们先看下面的例程，这个例程不需要解释吧，很像C语言里的函数指针，在C语言里这样的东西见得多了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var plus = function(x,y){
    document.write( x + &amp;#39; + &amp;#39; + y + &amp;#39; = &amp;#39; + (x+y) + &amp;#39;  
&amp;#39;);
    return x + y;
};

var minus = function(x,y){
    document.write(x + &amp;#39; - &amp;#39; + y + &amp;#39; = &amp;#39; + (x-y) + &amp;#39;  
&amp;#39;);
    return x - y;
};

var operations = {
    &amp;#39;+&amp;#39;: plus,
    &amp;#39;-&amp;#39;: minus
};

var calculate = function(x, y, operation){
    return operations[operation](x, y);
};

calculate(12, 4, &amp;#39;+&amp;#39;);
calculate(24, 3, &amp;#39;-&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，我们能不能把这些东西封装起来呢，我们需要使用prototype。看下面的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Cal = function(x, y){
    this.x = x;
    this.y = y;
}

Cal.prototype.operations = {
    &amp;#39;+&amp;#39;: function(x, y) { return x+y;},
    &amp;#39;-&amp;#39;: function(x, y) { return x-y;}
};

Cal.prototype.calculate = function(operation){
    return this.operations[operation](this.x, this.y);
};

var c = new Cal(4, 5);

c.calculate(&amp;#39;+&amp;#39;);
c.calculate(&amp;#39;-&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是prototype的用法，prototype 是javascript这个语言中最重要的内容。网上有太多的文章介始这个东西了。说白了，prototype 就是对一对象进行扩展，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的（当然， 这里没有真正的复制，实际只是委托）。上面的这个例子中，我们扩展了实例Cal，让其有了一个operations的属性和一个calculate的方法。&lt;/p&gt;

&lt;p&gt;这样，我们可以通过这一特性来实现继承。还记得我们最最前面的那个Person吧， 下面的示例是创建一个Student来继承Person。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name, email, website){
    this.name = name;
    this.email = email;
    this.website = website;
};

Person.prototype.sayHello = function(){
    var hello = &amp;quot;Hello, I am &amp;quot;+ this.name  + &amp;quot;,   
&amp;quot; +
                &amp;quot;my email is: &amp;quot; + this.email + &amp;quot;,   
&amp;quot; +
                &amp;quot;my website is: &amp;quot; + this.website;
    return hello;
};

function Student(name, email, website, no, dept){
    var proto = Object.getPrototypeOf;
    proto(Student.prototype).constructor.call(this, name, email, website);
    this.no = no;
    this.dept = dept;
}

// 继承prototype
Student.prototype = Object.create(Person.prototype);

//重置构造函数
Student.prototype.constructor = Student;

//重载sayHello()
Student.prototype.sayHello = function(){
    var proto = Object.getPrototypeOf;
    var hello = proto(Student.prototype).sayHello.call(this) + &amp;#39;  
&amp;#39;;
    hello += &amp;quot;my student no is: &amp;quot; + this. no + &amp;quot;,   
&amp;quot; +
             &amp;quot;my departent is: &amp;quot; + this. dept;
    return hello;
};

var me = new Student(
    &amp;quot;Chen Hao&amp;quot;,
    &amp;quot;haoel@hotmail.com&amp;quot;,
    &amp;quot;http://coolshell.cn&amp;quot;,
    &amp;quot;12345678&amp;quot;,
    &amp;quot;Computer Science&amp;quot;
);
document.write(me.sayHello());&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id3911'&gt;兼容性&lt;/h4&gt;

&lt;p&gt;上面的这些代码并不一定能在所有的浏览器下都能运行，因为上面这些代码遵循 ECMAScript 5 的规范，关于ECMAScript 5 的浏览器兼容列表，你可以看这里“&lt;a href='http://kangax.github.com/es5-compat-table/'&gt;ES5浏览器兼容表&lt;/a&gt;”。&lt;/p&gt;

&lt;p&gt;本文中的所有代码都在Chrome最新版中测试过了。&lt;/p&gt;

&lt;p&gt;下面是一些函数，可以用在不兼容ES5的浏览器中：&lt;/p&gt;

&lt;h5 id='objectcreate'&gt;Object.create()函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;function clone(proto) {
    function Dummy() { }

    Dummy.prototype             = proto;
    Dummy.prototype.constructor = Dummy;

    return new Dummy(); //等价于Object.create(Person);
}

var me = clone(Person);&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id='defineproperty'&gt;defineProperty()函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;function defineProperty(target, key, descriptor) {
    if (descriptor.value){
        target[key] = descriptor.value;
    }else {
        descriptor.get &amp;amp;&amp;amp; target.__defineGetter__(key, descriptor.get);
        descriptor.set &amp;amp;&amp;amp; target.__defineSetter__(key, descriptor.set);
    }

    return target
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id='keys'&gt;keys()函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;function keys(object) { var result, key
    result = [];
    for (key in object){
        if (object.hasOwnProperty(key))  result.push(key)
    }

    return result;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id='objectgetprototypeof_'&gt;Object.getPrototypeOf() 函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;function proto(object) {
    return !object?                null
         : &amp;#39;__proto__&amp;#39; in object?  object.__proto__
         : /* not exposed? */      object.constructor.prototype
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id='bind_'&gt;bind 函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var slice = [].slice

function bind(fn, bound_this) { var bound_args
    bound_args = slice.call(arguments, 2)
    return function() { var args
        args = bound_args.concat(slice.call(arguments))
        return fn.apply(bound_this, args) }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id3912'&gt;参考&lt;/h4&gt;

&lt;p&gt;* W3CSchool * MDN (Mozilla Developer Network) * MSDN (Microsoft Software Development Network) * Understanding Javascript OOP&lt;a href='http://killdream.github.com/blog/2011/10/understanding-javascript-oop/'&gt;http://killdream.github.com/blog/2011/10/understanding-javascript-oop/&lt;/a&gt;. * 基于ECMAScript5的继承链实现&lt;a href='http://www.oschina.net/code/snippet_58016_4157'&gt;http://www.oschina.net/code/snippet_58016_4157&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>jQuery1.4.3核心源码解读</title>
   <link href="http://heiniuhaha.github.com/jquery/2012/07/30/jquery-1.4.3-core-source"/>
   <updated>2012-07-30T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/jquery/2012/07/30/jquery-1.4.3-core-source</id>
   <content type="html">&lt;h3 id='jquery'&gt;构造jquery.&lt;/h3&gt;

&lt;p&gt;相对于其它库里传统的构造对象方法. jquery提供了一种截然不同的方法. 它选择创造一个全新的奇异世界.&lt;/p&gt;

&lt;p&gt;首先所有的jquery代码被一个自动执行的闭包包裹起来, 只在后面暴露$和jQuery这2个变量给外界 尽量避开变量冲突.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(window,  undefined){  
…..  
})(window)  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;window和undefined都是为了减少变量查找所经过的scope. 当window通过传递给闭包内部之后, 在闭包内部使用它的时候, 可以把它当成一个局部变量, 显然比原先在window scope下查找的时候要快一些. undefined也是同样的道理, 其实这个undefined并不是javascript数据类型六君子之一的undefined, 而是一个普普通通的变量名. 只是因为没给它传递值. 它的值就是undefined. undefined并不是javascript的保留字.&lt;/p&gt;

&lt;p&gt;然后是一个套子套住jquery的构造方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jQuery = (function(){   --------------------jq1  
    var jQuery = function( selector, context ){    ---------------jq2  
        ……..  
};  
    return (window.jQuery = window.$ = jQuery);  
})()  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先定义jq1, 这个jQuery最终在&lt;code&gt;return  (window.jQuery = window.$ = jQuery)&lt;/code&gt;的时候会变成 window下面的变量供外界使用. 而jq2供jquery内部执行的时候调用. 最终作为jq1的引用返回. &lt;code&gt;return (window.jQuery = window.$ = jQuery);&lt;/code&gt;这句话等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.jQuery = window.$ = jQuery;  
return window. jQuery.  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在来看看jquery对象是怎么被创建出来的. jquery作为一个独立特行的库, 它产生jquery对象时并不需要用new 操作符.. 它宁愿选择这种方式, 比如要产生一个构造函数Man的对象.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Man(name){  
    this.name = name;     
}  
  
function People(name){  
    return new Man(name);  
}  
  
var pe = People(&amp;quot;zengtan&amp;quot;);  
alert (pe.name);  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样真正作为jQuery对象的构造方法的并不是 function (selector, context){ } 而是&lt;code&gt;jQuery.fn.init. &lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jQuery  =  function( selector, context ) {            
        return new jQuery.fn.init( selector, context );  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery.fn就是jQuery.prototype. 见源码102行. &lt;code&gt;jQuery.fn = jQuery.prototype = {} &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;init是挂在jQuery.prototype上的属性. 当&lt;code&gt;jQuery(‘div’)&lt;/code&gt;的时候, 实际上转交给了&lt;code&gt;jQuery.fn.init&lt;/code&gt;构造函数来生成对象. 当然我们想用new jQuery来生成jquery对象也可以. 跟直接用jQuery()没区别. 因为构造函数一定会返回一个对象.如果显示指定了返回某个对象.就会返回那个对象, 否则才会返回this对象. 好比说, 有只母鸡被你强迫下一个蛋, 它会先看窝里有没有别人的蛋, 如果没有,才会自己努力下一个. 这里显然返回的是jQuery.fn.init的对象.&lt;/p&gt;

&lt;p&gt;也许现在你开始回忆制作jquery插件时, 明明是给jQuery.prototype添加方法. 这里返回的又是jQuery.prototype.init的对象. 原来在源码333行, jQuery.prototype.init.prototype = jQuery. prototype; 现在很容易看明白. 给jQuery.prototype添加方法就等于给jQuery. prototype.init.prototype添加方法了. JQuery api里的方法大部分都是通过jQuery.prototype扩展上去的, 除此之外. 我们还要给jquery对象加上索引. 给集合添加length属性,让他们更像一个数组里的元素.&lt;/p&gt;

&lt;p&gt;搞明白这些, 再来看jQuery. prototype.init这个方法里究竟是怎样生产jquery对象的. 我们可以把jQuery. prototype.init想象成一个火腿肠加工器. 只要你放了正确的原料进去, 它就可以把原料变成火腿肠生产出来.如果你不小心放错了原料.它也会帮你变成火腿肠. 不过只有塑料包装, 里面没有火腿. 当然这个加工器里面的构造是很复杂的, 它需要判断材料种类, 数量等等. 一般这个材料主要为这4种情况 1 dom节点 2 字符串 3 函数 4 数组 5 其他元素&lt;/p&gt;

&lt;p&gt;一 jQuery构造方法 jQuery的构造方法会生成一组jquery对象的集合.具体关于init方法的分析, 还是留在选择器部分说吧.&lt;/p&gt;

&lt;h3 id='jquery'&gt;jQuery对象访问&lt;/h3&gt;

&lt;p&gt;jquery构造完对象之后, 会提供一些方法访问这些对象.&lt;/p&gt;

&lt;p&gt;1 jQuery.prototype.size&lt;br /&gt;集合内元素的数量 就是通过this.length得到.&lt;/p&gt;

&lt;p&gt;2 jQuery.prototype.get&lt;br /&gt;按照索引取得集合内某个元素, 返回包装前的原始对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get: function( num ) {  
        return num == null ?   
 //如果参数为null或者undefiend. 注意是==.  
            this.toArray() :  //如果不传参数, 集合内的元素全部转化为一个数组(1)  
            ( num &amp;lt; 0 ? this.slice(num)[ 0 ] : this[ num ] );   
//调用silce方法截取某一个.可以传入负数并且返回的是包装前的对象.  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) 看看这里的this.toArray函数.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;toArray: function() {  
        return slice.call( this, 0 );  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单, 就是让当前jquery对象冒充Array的对象, 调用Array.prototype.slice进行截断. 返回的是一个数组. 至于为什么可以像这样使用对象冒充. 我们抽个地方来好好讨论一下. 其实如果查看v8之类开源引擎的源码就知道(当然也可以在ecma里挣扎一番). 要调用Array原型链上的方法. 通常这个对象满足2个条件就可以了. 1, 本身可以存取属性. 2, length属性不能是只读(可以没有length属性). 由于Array.prototype.slice方法太长了. 我拿Array.prototype.push方法举例. 在V8的src目录下的array.js可以找到这些方法. 比如push&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function ArrayPush() {  
  var n = ToUint32(this.length);  
 /* 
    对象/数组本身的length. 如果为null或者undefined, 会在ToUint32中转化为0. 所以 
    即使没有length属性,也会给一个默认的0值. 
 */  
  var m = %_ArgumentsLength();    //参数的length.  
  for (var i = 0; i &amp;lt; m; i++) {  
    this[i+n] = %_Arguments(i);   //复制属性  
  }  
  this.length = n + m;            //重设length.  
  return this.length;  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到push操作的核心就是复制属性和重设长度. jquery对象完全可以满足这2个条件. 同样的道理 一个对象字面量{}也可以. 而string类型的不可以, 因为不能在string上存取属性. function对象虽然可以存取属性, 也有length属性. 不过它的length属性比较特殊, 表示形参的个数, 是一个只读属性, 源码中的this.length = n + m这一句不起作用, 所以function对象也不行. 同理window对象也不行. 上面的slice.call也是这个原理, 虽然slice方法的实现更复杂一点.&lt;/p&gt;

&lt;p&gt;明白了这个,我们可以解释很多奇怪的问题.比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = {};  
a[0] = 1;  
a[1] = 2;  
Array.prototype.push(a, 3);  
alert (a.length)   // a没有length属性, 默认的给0值, 所以结果为1 .  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在push操作之前添加一句 a.length = 2; 再进行push操作后, a.length就为3了.&lt;/p&gt;

&lt;p&gt;3 jQuery.prototype.index&lt;br /&gt;搜索匹配的元素，并返回相应元素的索引值，从0开始计数。 如果不给 .index() 方法传递参数，那么返回值就是这个jQuery对象集合中第一个元素相对于其同辈元素的位置。 如果参数是一组DOM元素或者jQuery对象，那么返回值就是传递的元素相对于原先集合的位置。 如果参数是一个选择器，那么返回值就是原先元素相对于选择器匹配元素中的位置。如果找不到匹配的元素，则返回-1。 没有什么特别需要解释的, 直接看代码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index: function( elem ) {  
        if ( !elem || typeof elem === &amp;quot;string&amp;quot; ) {     
        //如果没有参数, 或者参数是选择器.  
            return jQuery.inArray( this[0],  
                elem ? jQuery( elem ) : this.parent().children() );  
        //如果有参数(选择器), 则查找元素本身在这些选择器组成的jq对象集合中的位置  
        //如果没有参数, 查找元素本身在它的兄弟节点之间的位置. this.parent().children()可以取得自己和全部兄弟节点.  
}  
        return jQuery.inArray(  
            //参数是一个对象  
            elem.jquery ? elem[0] : elem, this );  
            //如果是jquery对象, 取得它的原始节点. 再查找在当前集合中的位置     
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顾名思义jQuery.inArray就是判断数组里有没有某个元素.当然这里的数组也包括伪数组. 这个方法虽然实现起来很简单, 关于inArray这个名字在jquery的官方论坛却有颇多争议. 很多人认为它应该返回true或者false, 而不是索引的位置. john resig只是说暂时还不准备修改这个方法.&lt;/p&gt;

&lt;p&gt;有些浏览器还不支持Array.prototype.indexOf方法. 所以首先在源码的851行, 有这样一段代码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( Array.prototype.indexOf ) {  
    jQuery.inArray = function( elem, array ) {  
        return indexOf.call( array, elem );  
    };  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果支持Array.prototype.indexOf. 则重写jQuery.inArray, 直接用Array.prototype.indexOf.call(array, elem ); 在页面加载的时候就重写这个方法. 也避免了在函数里反复判断造成的浪费. 然后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inArray: function( elem, array ) {  
        if ( array.indexOf ) {  
//确认indexOf方法存在.或防止indexOf方法被改写.  
            return array.indexOf( elem );  
        }  
        for ( var i = 0, length = array.length; i &amp;lt; length; i++ ) {  
            //否则遍历数组, 返回正确的索引.  
if ( array[ i ] === elem ) {  
                return i;  
            }  
        }  
        return -1;  //如果数组里没有这个元素, 返回-1.  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id3904'&gt;数据缓存&lt;/h3&gt;

&lt;p&gt;jQuery.data&lt;/p&gt;

&lt;p&gt;在实际应用中, 我们经常需要往节点中缓存一些数据. 这些数据往往和dom元素紧密相关. dom节点也是对象, 所以我们可以直接扩展dom节点的属性. 不过肆意污染dom节点是不良少年的行为. 我们需要一种低耦合的方式让dom和缓存数据能够联系起来.&lt;/p&gt;

&lt;p&gt;jquery提供了一套非常巧妙的缓存办法.&lt;/p&gt;

&lt;p&gt;我们先在jquery内部创建一个cache对象{}, 来保存缓存数据.&lt;/p&gt;

&lt;p&gt;然后往需要进行缓存的dom节点上扩展一个值为&lt;code&gt;jQuery.expando&lt;/code&gt;的属性, 这里是&lt;code&gt;&amp;quot;jquery&amp;quot; + (new Date).getTime(). &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接着把每个节点的&lt;code&gt;dom[jQuery.expando]&lt;/code&gt;的值都设为一个自增的变量id,保持全局唯一性. 这个id的值就作为cache的key用来关联dom节点和数据. 也就是说cache&lt;span&gt;id&lt;/span&gt;就取到了这个节点上的所有缓存.&lt;/p&gt;

&lt;p&gt;而每个元素的所有缓存都被放到了一个map里面,这样可以同时缓存多个数据.&lt;/p&gt;

&lt;p&gt;比如有2个节点dom1和dom2, 它们的缓存数据在cache中的格式应该是这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cache = {  
    dom1[  jQuery.expando ]: {  
        key1: value1,  
        key2: value2  
	},  
	dom2[ jQuery.expando ] {  
	    key3: value3,  
	    key4: value4  
	}  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;jQuery.expando&lt;/code&gt;的值等于 &lt;code&gt;&amp;quot;jquery&amp;quot;+当前时间&lt;/code&gt;, 元素本身具有这种属性而起冲突的情况是微乎其微的.&lt;/p&gt;

&lt;p&gt;我们在看源码之前, 先根据上面的原理来自己实现一个简单的缓存系统.以便增强理解.&lt;/p&gt;

&lt;p&gt;先把跟data相关的所有代码都封装到一个闭包里,通过返回的接口暴露给外界. 同时为了简便,我们拆分成setData和getData两个方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;ddd&amp;quot;&amp;gt;dddddddd&amp;lt;/div&amp;gt;  
  
&amp;lt;script&amp;gt;  
  
var Data = function(){  
    var cache = {};  
    var expando = &amp;quot;zengtan&amp;quot; + +new Date;  
    var uuid = 1;  
      
    var setData = function(elem, key, value){  
            var id = elem[expando];  
            if (!id){   //第一次给元素设置缓存  
                id = ++uuid;  
                elem[expando] = id;  
            }  
            if (!cache[id]){   //这个元素第一次进行缓存或者缓存已被清空  
                cache[id] = {};  
            }  
            cache[id][key] = value;  
    };  
  
    var getData = function(elem, key){  
        var id = elem[expando];  //取得cache里跟dom节点关联的key  
        return cache[id] &amp;amp;&amp;amp; cache[id][key] || null;  //如果缓存里没有, 返回null  
    }  
  
    return {  
        setData: setData,  
        getData: getData      
    }  
}()  
  
&amp;lt;/script&amp;gt;  
  
var div = document.getElementById(&amp;quot;ddd&amp;quot;);  
Data.setData(div, &amp;quot;name&amp;quot;, &amp;quot;zengtan&amp;quot;);  
var value = Data.getData(div, &amp;quot;name&amp;quot;);  
alert (value)  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看源码实现.&lt;/p&gt;

&lt;p&gt;首先声明一些特殊的节点, 在它们身上存属性的时候可能会抛出异常.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;noData: {  
        &amp;quot;embed&amp;quot;: true,  
        // Ban all objects except for Flash (which handle expandos)  
        &amp;quot;object&amp;quot;: &amp;quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&amp;quot;,  
        &amp;quot;applet&amp;quot;: true  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个对象里的数据用在acceptData方法中, 跟1.42版本相比, 这里多了对什么flash的object的特殊处理. 总之acceptData方法就是判断节点能否添加缓存.&lt;/p&gt;

&lt;p&gt;看具体的jQuery.data&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data: function( elem, name, data ) {  
    if ( !jQuery.acceptData( elem ) ) {  
        return;  
    }  
    //noData类型  
    elem = elem == window ?  
        windowData :  
        elem;  
    //处理elem是window的情况, 如果不单独处理的话, 等于增加了一个全局变量, windowData也是一个{}  
    var isNode = elem.nodeType,  
    //判断是不是dom节点,由于非dom节点的缓存在继承和内存泄露上都会造成麻烦,1.43版本已经把dom节点和其他对象分开处理了.  
        id = isNode ? elem[ jQuery.expando ] : null,  
        cache = jQuery.cache, thisCache;  
    //因为存数据的时候, 会给elem[ jQuery.expando ]设置一个全局唯一标志量. 判断id是否为undefined, 就知道已经有没有往这个元素上缓存过数据.   
  
    if ( isNode &amp;amp;&amp;amp; !id &amp;amp;&amp;amp; typeof name === &amp;quot;string&amp;quot; &amp;amp;&amp;amp; data === undefined ) {  
    //如果是dom节点对象, 并且现在是get方式(typeof name === &amp;quot;string&amp;quot; &amp;amp;&amp;amp; data === undefined表示get方式), 又没有缓存(!id表示没有缓存).  
        return;  
    }  
  
    if ( !isNode ) {  
        cache = elem;  
    //如果是非dom节点对象, 取缓存里的属性就直接取元素本身属性.  
    } else if ( !id ) {  
        elem[ jQuery.expando ] = id = ++jQuery.uuid;  
    //第一次进行缓存, 分配一个全局唯一标志id.  
    }  
  
    if ( typeof name === &amp;quot;object&amp;quot; ) {  
    //如果key是对象类型  
        if ( isNode ) {  
            cache[ id ] = jQuery.extend(cache[ id ], name);  
    /* 
    把整个对象都复制到原来的缓存上, 比如 
         $(&amp;#39;#ddd&amp;#39;).data({ 
                &amp;quot;v2&amp;quot;: &amp;quot;bbb&amp;quot;, 
                &amp;quot;v3&amp;quot;: &amp;quot;ccc&amp;quot; 
            }); 
            相当于$(&amp;#39;#ddd&amp;#39;).data(&amp;quot;v2&amp;quot;, &amp;quot;bbb&amp;quot;).data(&amp;quot;v3&amp;quot;:&amp;quot;ccc&amp;quot;); 
            1.42版本用的cache[ id ] = jQuery.extend(true, {}, name). 这样会清空以前的缓存. 
        */  
        } else {  
            jQuery.extend( cache, name );  
        //如果不是dom节点. 把属性复制到元素本身.  
        }  
  
    } else if ( isNode &amp;amp;&amp;amp; !cache[ id ] ) {  
        //如果cache[ id ]中没有东西, 表示这个元素第一次进行缓存或者缓存已被清空, 设置cache[ id ]为一个新的map.  
        cache[ id ] = {};  
    }  
  
    thisCache = isNode ? cache[ id ] : cache;  
  
    if ( data !== undefined ) {  
        /* 
            set操作, 也可以防止一些意外的情况下缓存被清空. 比如data未定义的情况下, 缓存操作是无效的. 
            var a = {}; 
            var b; 
            $(a).data(&amp;quot;c&amp;quot;, 3); 
            $(a).data(&amp;quot;c&amp;quot;, b); b为undefined. 这句是无效的. 要移除缓存可以用removeData方法. 
        */  
        thisCache[ name ] = data;  
        //即cache[ id ][ name ] = data, 把data设置进cache缓存对象中, 前面分配的自增id当做key来关联  
    }  
  
    return typeof name === &amp;quot;string&amp;quot; ? thisCache[ name ] : thisCache;  
    //如果key是string类型, 返回key对应的缓存, 否则返回整个元素上的缓存  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从新版本的源码里可以看到, 1.42版本中data方法的几个缺点已经被解决了.&lt;/p&gt;

&lt;p&gt;当然我们用jquery缓存系统的时候, 一般调用的是prototype方法, prototype方法除了调用上面的静态方法之外. 还加入了对节点上自定义事件的处理, 留在event部分再讲.&lt;/p&gt;

&lt;p&gt;当然, 我们还需要删除缓存的方法. 现在看看removeData的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Jquery.removeData  
  
    removeData: function( elem, name ) {  
        if ( !jQuery.acceptData( elem ) ) {  
            return;  
        }  
  
        elem = elem == window ?  
            windowData :  
            elem;  
  
        var isNode = elem.nodeType,  
            id = isNode ? elem[ jQuery.expando ] : elem,  
            //id是该元素在cache上面的key, 如果不是节点就返回元素本身.  
            cache = jQuery.cache,  
            thisCache = isNode ? cache[ id ] : id;  
  
        if ( name ) {  
            if ( thisCache ) {  
                delete thisCache[ name ];  
                //删除key对应的缓存数据  
                if ( isNode &amp;amp;&amp;amp; jQuery.isEmptyObject(thisCache) ){  
                    //如果元素是dom节点并且缓存为一个空对象.说明所有缓存的数据都已经被删掉了.  
                    //那么重新调用一次removeData方法, 删掉缓存系统里已经无用的东西, 防止内存泄露, 注意现在走的是下面else分支.   
                    jQuery.removeData( elem );   
                }  
            }  
        } else {  
            if ( isNode &amp;amp;&amp;amp; jQuery.support.deleteExpando ) {  
                //如果支持delete, 见特性检测部分.  
                delete elem[ jQuery.expando ];  
                //删掉元素的jQuery.expando属性  
  
            } else if ( elem.removeAttribute ) {  
                //如果支持removeAttribute  
                elem.removeAttribute( jQuery.expando );  
  
            } else if ( isNode ) {  
                delete cache[ id ];  
                //如果是dom节点, 全局缓存里删除以这个id为key的对象.  
            } else {  
                for ( var n in elem ) {  
                    //如果是其它对象, 删除对象的所有属性. 防止内存泄露.  
                    delete elem[ n ];  
                }  
            }  
        }  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id3905'&gt;队列控制&lt;/h3&gt;

&lt;p&gt;队列控制也是jquery中很有特点的一个功能. 可以用来管理动画或者事件等的执行顺序. queue和dequeue主要为动画服务. 比如在jquery的动画里, 因为javascript的单线程异步机制, 如果要管理一批动画的执行顺序, 而不是让它们一起在屏幕上飞舞. 一般我们是一个一个的把下个动画写在上个动画的回调函数中, 意味着如果要让十个动画按次序执行. 至少要写9个回调函数. 好吧我承认我做过这样的事, 直接导致我的视力从5.2变为5.1.&lt;/p&gt;

&lt;p&gt;现在有了队列机制, 可以把动画都放到队列中依次执行.究竟怎样把动画填充进队列.用的是queue方法. 不过queue非常先进的是.把动画push进队列之后,还会自动去执行队列里的第一个函数. 队列机制里面的另外一个重要方法是dequeue, 意为取出队列的第一个函数并执行.此时队列里面的函数个数变为N-1.&lt;/p&gt;

&lt;p&gt;看个例子.比如我要让2个div以动画效果交替隐藏和显示.同时只能有一个div在进行动画.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;   
#div1 {background:#aaa;width:188px;height:188px;position:absolute;top:10px;left: 110px;}  
#div2 {background:#aaa;width:188px;height:188px;position:absolute;top:310px;left: 110px;}  
&amp;lt;/style&amp;gt;  
  
&amp;lt;body&amp;gt;   
&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;我是一个div&amp;lt;/div&amp;gt;  
&amp;lt;div id=&amp;quot;div2&amp;quot;&amp;gt;我是另一个div&amp;lt;/div&amp;gt;  
&amp;lt;/body&amp;gt;  
  
//用queue可以这样做.  
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;  
$(document).queue([  
    function(fn){  
        $(&amp;quot;#div1&amp;quot;).hide(1000, fn);   
      //fn === $(document).dequeue;  
    },  
    function(fn){  
        $(&amp;quot;#div2&amp;quot;).hide(1000, fn);  
    },  
    function(fn){  
        $(&amp;quot;#div1&amp;quot;).show(1000, fn);  
    },  
    function(fn){  
        $(&amp;quot;#div2&amp;quot;).show(1000, fn);  
    }  
])  
&amp;lt;/script&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们需要一个载体, 来保存这个队列, 这里选择了document. 其实选什么节点都一样, 保存队列其实也是一个jQuery.data操作. 然后queue的参数是一个数组. 里面的函数就是队列依次执行的函数. 前面讲到, queue方法会自动把队列里的第一个函数取出来执行. 意味着这些代码写完后, div1已经开始渐渐隐藏了. 隐藏完毕后, 如果要让后面的动画继续执行, 还要用$(document).dequeue()继续取出并执行现在队列里的第一个函数. 当然这个操作是放在第一个动画的回调函数里, 以此类推, 第二个.dequeue()要放在第二个动画的回调函数里. 我们看到这里没有用$(document).dequeue(). 因为这句代码太长. 注意队列函数里有一个参数fn, fn是dequeue方法内部传给此函数的, 就是$(document).dequeue().&lt;/p&gt;

&lt;p&gt;在看源码之前, 先自己来想想这个功能应该怎么实现. 首先我们需要一个数组, 里面存放那些动画. 然后需要2个方法, set和get.可以存取动画. 可能我们还需要一个变量来模拟线程锁, 保证队列里的函数不会同时被执行. 最后我们要把这个数组存入dom的缓存中, 方便随时存取和删除.&lt;/p&gt;

&lt;p&gt;看源码, 先是prototype方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.prototype.queue = function( type, data ) {  
        if ( typeof type !== &amp;quot;string&amp;quot; ) {  
            data = type;  
            type = &amp;quot;fx&amp;quot;;    
//修正type, 默认为表示jquery动画的fx, 如果不为&amp;quot;fx&amp;quot;, 即为自己的自定义动画, 一般我们用&amp;quot;fx&amp;quot;就足够了.  
        }  
        if ( data === undefined ) {   
            return jQuery.queue( this[0], type );    
//get队列. 不论集合中是单个或者多个元素, 总是返回第一个元素的队列  
        }  
        return this.each(function( i, elem ) {    
//set队列, 遍历集合内所有元素  
            var queue = jQuery.queue( this, type, data );    
//set并返回队列  
            if ( type === &amp;quot;fx&amp;quot; &amp;amp;&amp;amp; queue[0] !== &amp;quot;inprogress&amp;quot; ) {  
         //防止在执行函数的时候, 这里又进行dequeue操作, 这样会同时执行2个函数, 队列就不受控制了.  
                jQuery.dequeue( this, type );      
//如果队列没有被锁住, 即此时没有在执行dequeue. 移出队列里第一个函数并执行它.  
//毕竟queue的主要任务是添加队列, 执行函数的操作上, 只能当二等公民.  
            }  
        });  
    }  
看看jQuery.queue这个静态方法.  
    jQuery.queue = function( elem, type, data ) {  
        if ( !elem ) {  
            return;  
        }  
        type = (type || &amp;quot;fx&amp;quot;) + &amp;quot;queue&amp;quot;;  
        var q = jQuery.data( elem, type );  
        //取得元素缓存上面的队列  
        if ( !data ) {    
        //如果当data为空, 只是查询queue. 那么返回队列或者[]  
return q || [];  
        }  
        if ( !q || jQuery.isArray(data) ) {  
            q = jQuery.data( elem, type, jQuery.makeArray(data) );   
        /*否则是set操作，注意!q || jQuery.isArray(data)这句代码的含义,   
		如果q为null, 说明缓存上没有队列. 此时哪怕队列里只有一个函数, 也把它转成数组, 保证队列是数组形式  
        如果q不为null, 说明缓存上已经存在队列, 但是如果现在被添加的函数是一个数组的话, 以现在的数组来代替原来的队列, 即把原来的队列清空了.  
        clearQueue函数就是用的这一句代码执行清空队列操作. 
        */    
} else {  
            q.push( data );  
        //缓存上有队列并且只添加一个函数  
        }  
        return q;  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再看dequeue, dequeue的原型方法什么也没做, 直接把参数交给jQuery.dequeue来处理.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dequeue: function( elem, type ) {  
    type = type || &amp;quot;fx&amp;quot;;  
    var queue = jQuery.queue( elem, type ), fn = queue.shift();  
    //取得队列, 和队列里的第一个元素, 这里直接给shift掉了, 先斩后奏.  
    if ( fn === &amp;quot;inprogress&amp;quot; ) {  
        //如果fn===” inprogress”, 说明杀错了人, 我要找的是函数  
        fn = queue.shift();  
        //继续找下一个, 下一个肯定是函数了.  
        }  
        if ( fn ) {  
            if ( type === &amp;quot;fx&amp;quot; ) {  
                queue.unshift(&amp;quot;inprogress&amp;quot;);  
        //函数执行前, 在queue数组的最前面添加一个进程锁, 复活刚才杀错的人.   
		 	  }  
  
            fn.call(elem, function() {  
        //执行函数, 参数就是前面的fn  
                jQuery.dequeue(elem, type);  
            });  
        }  
	}  
})  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“inprogress”进程锁是这样工作的： 如果是dequeue操作, 去掉锁, 执行队列里的函数, 同时给队列加上锁. 如果是queue操作, 要看锁的状态, 如果被锁上了, 就只执行队列的添加操作. 不再调用dequeue. 其实dequeue和queue都可以执行队列里的第一个函数.queue操作添加完队列之后, 会调用dequeue方法去执行函数. 但是用dequeue执行函数的时候, 这时候如果又用queue触发dequeue的话, 很可能同时有2个函数在执行. 队列就失去一大半意义了(还是可以保证顺序, 但是2个动画会同时执行). 不过这个锁只能保证在dequeue的时候, 不被queue操作意外的破坏队列. 如果人为的同时用2个dequeue, 还是会破坏动画效果的. 所以要把fn写在回调函数里.&lt;/p&gt;

&lt;p&gt;清空队列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clearQueue: function( type ) {  
    return this.queue( type || &amp;quot;fx&amp;quot;, [] );  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理上面已经提到过了, 就是这一句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( !q || jQuery.isArray(data) ) {  
    q = jQuery.data( elem, type, jQuery.makeArray(data) );   
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用一个空数组代替了原来的队列.&lt;/p&gt;

&lt;h3 id='id3906'&gt;多库共存&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;jQuery.noConflict&lt;/code&gt; 将变量$的控制权让渡给上一个实现它的那个库. 可能很多人都被多库共存时的$变量问题困扰过. 比如你先引入了prototype库,然后又引入了jquery.因为jquery的$会覆盖prototype的$. 现在想调用prototype的$怎么办呢, noConflict方法就派上用场了. Jquery代码里最开始就有一句&lt;code&gt;_$ = window.$ &lt;/code&gt;, 在加载的时候就用&lt;code&gt;_$&lt;/code&gt;来引用原来的&lt;code&gt;$&lt;/code&gt; (比如现在就是prototype库里的$).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend({     
    noConflict: function( deep ) {  
        window.$ = _$;     
//window.$归还给原来的库. 要回归jquery再用window.$ = jQuery就可以了.  
        if ( deep ) {      
            window.jQuery = _jQuery;     
//如果deep为true, jQuery这个变量也可以归还, 不过一般不需要也不推荐这么做.  
        }  
        return jQuery;  
    }  &lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id3907'&gt;继承和拷贝&lt;/h4&gt;

&lt;p&gt;jQuery.prototype.extend和jQuery.extend 扩展 jQuery 元素集来提供新的方法, 或者把一个对象的属性拷贝到另外一个对象上. 通常javascript的继承实现有4种方式. 1 构造继承 2 prototype继承 3 属性拷贝 4 实例继承(这个有点特殊, 主要用于继承内置对象)&lt;/p&gt;

&lt;p&gt;这4种继承都有各自的优点和缺陷. 构造继承查找属性快.但无法继承原型链上的方法,而且每次都要为属性复制一份新的副本进行储存 原型继承在性能方面好一些,可以共享原型链.但查找属性慢,因为可能要遍历N条原型链才能找到某个属性.而且原型链太多,会使得结构越加混乱.并且会丢失对象的constructor属性 (对象的constructor总是指向原型链最上层的构造器) 属性拷贝非常灵活,但明显效率偏低. 而且仅仅只是模拟继承. 实例继承主要用来继承Array, Date等内置对象, 用的较少.&lt;/p&gt;

&lt;p&gt;jquery里采用的是属性拷贝.其实用哪种继承是个见仁见智的问题. 也有其它一些库就是用的原型继承.&lt;/p&gt;

&lt;p&gt;前面也可以注意到, jquery只在构造方法或者原型链上定义了少量的核心方法. 其它功能块都是通过extend函数拷贝上去.按需定制. 好比开发商交给我们房子的时候, 只安装了水电暖气等基本设施.电视机洗衣机显然是自己去买比较好.&lt;/p&gt;

&lt;p&gt;属性拷贝原理就是遍历第二个对象, 然后分别把键和值填入第一个对象中.类似于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var i in obj2){  
    Obj1[i] = obj2[i]  
}  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不幸的是jquery里面的做法复杂的多,不仅可以把多个参数的属性都复制到一个对象中,还能实现深度继承. 深度继承是指如果被继承对象和继承对象都有同名属性a, 而且这个属性的值分别是一个对象b和c.会把b和c的属性都合并到一个新的对象里, 作为值返回给合并后的对象. 说的有点复杂, 看个例子.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend( true,          
     { name: “John”, location: { city: “Boston” } },         
     { last: “Resig”, location: { state: “MA” } }         
 );          
  //结果为         
   {   
	  name: “John”, last: “Resig”,          
    location: { city: “Boston”, state: “MA” }   
   }  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery的做法主要是这样, 先修正参数,根据第一个参数是boolean还是object确定target是哪个对象. 如果有且只有一个object类型的参数, 则把这个参数里的属性copy到jQuery或者jQuery.prototype上, 扩展jQuery对象.用这个办法可以很方便的编写插件. 否则依次遍历第一个object参数之后的所有object类型对象的属性. 根据是否深度继承用不同的方式进行copy操作. extend会改变第一个参数的引用. 如果不想改变它,可以稍微变通一下,把所有的参数属性都拷贝到一个空对象上.如$.extend({}, obj1, obj2);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend = jQuery.fn.extend = function() {  
    var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy, copyIsArray;  
    //target应该指向被拷贝的对象, deep表示深度拷贝或者浅度拷贝, 如果为true,即深度拷贝.反之为浅度拷贝.  
  
    if ( typeof target === &amp;quot;boolean&amp;quot; ) {  
    //如果显示声明了是深度拷贝还是浅度拷贝  
        deep = target;  
    //重新设置deep  
        target = arguments[1] || {};  
    //修正target, 让它指向第二个参数  
        i = 2;  
    //修正循环开始的位置, copy的时候跳过deep和target, 指向第一个copy对象.  
    }  
  
    if ( typeof target !== &amp;quot;object&amp;quot; &amp;amp;&amp;amp; !jQuery.isFunction(target) ) {  
        //修正target. 确保target是一个可以迭代属性的对象, 从这句代码看出target可以为函数对象  
        target = {};  
    }  
    if ( length === i ) {  
        target = this;  
        --i;  
        /* 
            当只有一个参数是对象的情况(可能前面还有一个true或false).  
            把属性赋值给jquery或者jquery.fn. 帮jquery实现继承. 
            并且重新修正循环起始位置. 
        */  
    }  
  
    for ( ; i &amp;lt; length; i++ ) {  
        if ( (options = arguments[ i ]) != null ) {  
            //只遍历不为null的参数  
            for ( name in options ) {  //遍历copy对象的属性  
                src = target[ name ];    //记录target的属性值  
                copy = options[ name ];  //记录将要被copy进去的值  
                if ( target === copy ) { //防止死循环???  
                    continue;  
                }  
  
                if ( deep &amp;amp;&amp;amp; copy &amp;amp;&amp;amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {  
                    //如果是深度继承并且copy是对象字面量或者数组, 但必须保证至少为对象字面量和数组之一才会继续下面.  
                    //copyIsArray = jQuery.isArray(copy)返回的是boolean.  
                    //如果jQuery.isPlainObject(copy)和jQuery.isArray(copy)都是false,那整个if语句里的判断条件都返回false,  
                    //也就不会执行下面了的深度继承了.比起1.42版本, 很多地方功能没变, 代码还是明显清晰了很多.  
                    if ( copyIsArray ) {   //如果是数组  
                        copyIsArray = false; //重设copyIsArray  
                        clone = src &amp;amp;&amp;amp; jQuery.isArray(src) ? src : [];  
                    //防止深度copy的时候, target为undefined. 此时target应该为对象类型.   
                    //如果target本来为undefined, 要设一个不含属性的默认值, 且类型要跟copy对象保持一致.  
                    } else {  
                        clone = src &amp;amp;&amp;amp; jQuery.isPlainObject(src) ? src : {};  
                    //同上  
                    }  
                    target[ name ] = jQuery.extend( deep, clone, copy );  
                    //深度继承递归调用extend方法进行合并  
                } else if ( copy !== undefined ) {  
                    target[ name ] = copy;  
                    //浅度继承直接复制属性, 但是不要带入undefined值.  
                }  
            }  
        }  
    }  
  
    return target;  
    //返回合并后的对象. 第一个obj参数的引用已经被改变了.  
}  &lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>前端技术牛人列表</title>
   <link href="http://heiniuhaha.github.com/f2e/2012/07/30/f2e-master"/>
   <updated>2012-07-30T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/f2e/2012/07/30/f2e-master</id>
   <content type="html">&lt;h2 id='id3902'&gt;牛人列表&lt;/h2&gt;

&lt;p&gt;该页面列举了我仰慕的前端牛人和前端牛逼团队，以他们为榜样，站在巨人的肩膀上学习，能让我们再前端开发道路上更顺利。也推荐给大家学习的目标。会持续更新&amp;#8230;&lt;/p&gt;

&lt;h3 id='id3903'&gt;前端架构&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href='http://hikejun.com/blog/'&gt;张克军-kejun&lt;/a&gt;&lt;/strong&gt; 绝对大牛级别的人物，目前在豆瓣负责前端架构，经常出现在各种技术交流活动中，如咱熟知的D2&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href='http://lifesinger.wordpress.com/'&gt;玉伯-岁月如歌&lt;/a&gt;&lt;/strong&gt; 如今火热的Web 浏览器端的模块加载器seajs的开发者，目前在支付宝，研究型+实战型牛人，经常出现在各种技术交流活动中，如咱熟知的D2，乐于布道。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://alloyteam.github.com/'&gt;AlloyTeam on Github.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://cnblogs.com/Cson/'&gt;Cson&amp;#8217;s Room&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.gtdlife.com/'&gt;GTDLife | 时间管理行动家&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.html5dw.com/'&gt;HTML5 梦工场&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://imatlas.com'&gt;imatlas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://blog.biqing.me/'&gt;Infinity World&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://oscartong.tumblr.com/'&gt;iOSCAR&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.itzhai.com/'&gt;IT 宅&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://Kinvix.AlloyTeam.com'&gt;i在云端 – Kinvix&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://duwei.herokuapp.com/'&gt;Too simple to blog&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.v2ex.com/'&gt;V2EX&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.w3cplus.com/'&gt;W3C Plus&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.w3ctech.com/'&gt;W3CTech&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.css88.com'&gt;Web 前端开发&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://madscript.com/'&gt;元彦の程序世界&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.html6game.com/'&gt;前端开发网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.qianduan.net/'&gt;前端观察&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://hongru.cnblogs.com/'&gt;叶落为重生&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.quchao.com/'&gt;時計坂一刻館三号室&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://ued.taobao.com/'&gt;淘宝 UED&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.cnblogs.com/hooray/'&gt;胡尐睿丶可惜我是程序猿&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://cdc.tencent.com'&gt;腾讯 CDC&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://flashteam.tencent.com/'&gt;腾讯 FlashTeam&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://gdc.qq.com'&gt;腾讯 GDC&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://isd.tencent.com/'&gt;腾讯 ISD&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://impd.tencent.com/'&gt;腾讯 QQ客户端团队博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://tgideas.qq.com/'&gt;腾讯游戏 TGideas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://blog.lifeclaw.com'&gt;雪泥鸿爪&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.wheattime.com/'&gt;麦时&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>http协议介绍</title>
   <link href="http://heiniuhaha.github.com/http/2012/07/29/http-protocol"/>
   <updated>2012-07-29T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/http/2012/07/29/http-protocol</id>
   <content type="html">&lt;p&gt;此文正在进行中。。。&lt;/p&gt;

&lt;h3 id='id3901'&gt;参考文章：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html'&gt;互联网协议入门（一）-阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html'&gt;互联网协议入门（二）-阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>ruby更新版本</title>
   <link href="http://heiniuhaha.github.com/ruby/2012/07/20/ruby-update"/>
   <updated>2012-07-20T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/ruby/2012/07/20/ruby-update</id>
   <content type="html">&lt;p&gt;经常有人问： 怎么把mac默认的ruby版本切换到刚安装的新版本？&lt;/p&gt;

&lt;p&gt;答案很简单，用rvm吧&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rvm官方地址 &lt;a href='https://rvm.io/'&gt;https://rvm.io/&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;ruby更新实用详细教程 &lt;a href='http://ruby-china.org/wiki/rvm-guide'&gt;http://ruby-china.org/wiki/rvm-guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常用命令如下：&lt;/p&gt;

&lt;p&gt;安装rvm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -L https://get.rvm.io | bash -s stable --ruby&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将系统重置为最新版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source ~/.bashrc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看系统里的ruby版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;which -a ruby&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有ruby版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm list known&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用一个ruby版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm use 1.8.7&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非常简单，即使是mac新人，使用此命令进行版本控制也无任何压力啊。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>前端基础点</title>
   <link href="http://heiniuhaha.github.com/css/2012/07/11/f2e-interview"/>
   <updated>2012-07-11T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/css/2012/07/11/f2e-interview</id>
   <content type="html">&lt;h3 id='id3896'&gt;★★★★★功夫下在和工作有关的地方★★★★★&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1、用最优的方案实现需求。在自己的已有知识结构、能力、经验上用最好的方式实现需求，在此基础上努力搜寻业界相关的解决方案比较优劣，选出最佳的方案，最终实现需求。&lt;/li&gt;

&lt;li&gt;2、关心自己已做完工作，关注业界的相关新思想、新技术、新理念，把已完成的工作，用最新最优的方案予以重构，并在适当的时机在产品上得以实现。&lt;/li&gt;

&lt;li&gt;3、关注自己所负责工作的未来，把产品当做自己的孩子，努力将他引向最美好的未来。努力将自己所负责的产品打造成为业界的标杆(特别是自己所负责的部分，那是自己影响圈内的事情)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id='display'&gt;★列出display的值&lt;/h4&gt;

&lt;p&gt;可用值 值的说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;block 象块类型元素一样显示。&lt;/li&gt;

&lt;li&gt;none 缺省值。向行内元素类型一样显示。&lt;/li&gt;

&lt;li&gt;inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。&lt;/li&gt;

&lt;li&gt;list-item 象块类型元素一样显示，并添加样式列表标记。&lt;/li&gt;

&lt;li&gt;table-header-group 显示在任何表格行和行组合之前，在头部标题之后。&lt;/li&gt;

&lt;li&gt;table-footer-group 显示在任何表格行和行组合之后，在底部标题前。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id='id3897'&gt;★清除浮动与闭合浮动的不同点&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://www.cnblogs.com/mofish/archive/2012/05/14/2499400.html'&gt;http://www.cnblogs.com/mofish/archive/2012/05/14/2499400.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='addevent'&gt;★如何为元素绑定事件（就是addEvent）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function addEvent(elm, evType, fn, useCapture) {
  if (elm.addEventListener) {
    elm.addEventListener(evType, fn, useCapture);//DOM2.0
    return true;
  }else if (elm.attachEvent) {
    var r = elm.attachEvent(&amp;#39;on&amp;#39; + evType, fn);//IE5+
    return r;
  }else {
    elm[&amp;#39;on&amp;#39; + evType] = fn;//DOM 0
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='windowonbeforeunload_'&gt;★window.onbeforeunload 的用法&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://www.cnblogs.com/snandy/archive/2012/05/03/2481019.html'&gt;http://www.cnblogs.com/snandy/archive/2012/05/03/2481019.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='windowonerror'&gt;★说一下window.onerror的参数&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://blog.csdn.net/zzxll5566/article/details/6187943'&gt;http://blog.csdn.net/zzxll5566/article/details/6187943&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='ieff'&gt;★列出IE与FF的事件对象的不同点&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://www.ok12.net/js/125.html'&gt;http://www.ok12.net/js/125.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='css'&gt;★如何用CSS画三角形&lt;/h4&gt;

&lt;p&gt;(利用border属性)&lt;/p&gt;

&lt;h4 id='js'&gt;★你平时是如何调试JS代码的&lt;/h4&gt;

&lt;p&gt;(firebug,IE开发人员工具,opera, chrome是当中最好的)&lt;/p&gt;

&lt;h4 id='id3898'&gt;★如何判定一个脚本是否加载成功&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var script = document.createElement(&amp;#39;script&amp;#39;) ;
var head = document.getElementsByTagName(&amp;quot;head&amp;quot;)[0];
head.insertBefore(script, head.firstChild);//规避IE6下自闭合base标签BUG
script.onload = script.onreadystatechange = function(){//先绑定事件再指定src发出请求
    if(/loaded|complete|undefined/.test(this.readyState) &amp;amp;&amp;amp; !this.once ){
        this.once = 1;
        this.parentNode.removeChild(this);
    }
}
script.src = &amp;#39;http://files.cnblogs.com/rubylouvre/html5.js&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(IE onreadystatechange事件,判定节点的readyState值是否为loaded或complete, 其他浏览器则使用onload)&lt;/p&gt;

&lt;h4 id='iframe'&gt;★如何判定iframe里面的资源都加载完毕&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://www.cnblogs.com/lhgstudio/archive/2010/10/24/1859946.html'&gt;http://www.cnblogs.com/lhgstudio/archive/2010/10/24/1859946.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='dom'&gt;★怎么判定一个节点是在DOM树中&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://www.cnblogs.com/rubylouvre/archive/2009/10/14/1583523.html'&gt;http://www.cnblogs.com/rubylouvre/archive/2009/10/14/1583523.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='js'&gt;★指出JS拖动的原理&lt;/h4&gt;

&lt;p&gt;(将元素绝对定位,一点点地改变其top,left样式来实现移动的效果,top,left可以通过鼠标获取)&lt;/p&gt;

&lt;h4 id='css_transform2dtransform3d'&gt;★说一下css transform2D与transform3D的区别&lt;/h4&gt;

&lt;p&gt;(一个是2&lt;em&gt;3矩阵,一个是4&lt;/em&gt;4矩阵,transform3D支持GPU硬件加速,更加流畅,建议用transform3D模拟transform2D)&lt;/p&gt;

&lt;h4 id='id3899'&gt;★指出{}+&lt;span /&gt;与&lt;span /&gt;+{}的值,为什么&lt;/h4&gt;

&lt;p&gt;(第一个为0,因为{}放在语句在前面,JS引擎认为它只是一个块,不是空对象,相当于+&lt;span /&gt; ===&amp;gt; +&amp;#8221;&amp;#8221; ==&amp;gt; 0, 第二个是&amp;#8221;&lt;span&gt;object Object&lt;/span&gt;&amp;#8220;,两者取toString(),然后相加)&lt;/p&gt;

&lt;h4 id='ie'&gt;★说一下浏览器资源加载的情况,IE与其他浏览器各版本的不同之外&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://www.otakustay.com/browser-strategy-loading-external-resource/'&gt;http://www.otakustay.com/browser-strategy-loading-external-resource/&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='id3900'&gt;★说一下最近非常流行模块加载,大概是怎么实现的,有什么好处&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://www.cnblogs.com/muguaworld/archive/2011/11/27/2265356.html'&gt;http://www.cnblogs.com/muguaworld/archive/2011/11/27/2265356.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='javascript'&gt;★高性能JavaScript模板引擎原理解析&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://cdc.tencent.com/?p=5723'&gt;http://cdc.tencent.com/?p=5723&lt;/a&gt;&lt;/p&gt;

&lt;h3 id='1javascript'&gt;1.javascript对象的几种创建方式&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1）工厂方式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//定义

function createCar() {

	var oCar = new Object();
	
	oCar.color = &amp;quot;red&amp;quot;;
	
	oCar.doors = 4;
	
	oCar.showColor = function() {
	
		alert(this.color);
	
	}
	
	return oCar;

}

//调用

var ocar1 = createCar();

var ocar2 = createCar();

ocar1.color = &amp;quot;black&amp;quot;;

ocar1.showColor();

ocar2.showColor();

//修改createCar()函数，给它传递各个属性的默认值：


function createCar(sColor, iDoors, iMpg) {

	var oTempCar = new Object;
	
	oTempCar.color = sColor;
	
	oTempCar.doors = iDoors;
	
	oTempCar.mpg = iMpg;
	
	oTempCar.showColor = function () {
	
		alert(this.color);
	
	};
	
	return oTempCar;

}

var oCar1 = createCar(&amp;quot;red&amp;quot;, 4, 23);

var oCar2 = createCar(&amp;quot;blue&amp;quot;, 3, 25);

oCar1.showColor(); //outputs &amp;quot;red&amp;quot;

oCar2.showColor(); //outputs &amp;quot;blue&amp;quot;


//在工厂函数外定义对象的方法，然后通过属性指向该方法，

//从而避免每次调用函数createCar()，都要创建新函数showColor()。


function showColor(){

	alert(this.color);

}

function createCar(sColor, iDoors, iMpg){

	var oTempCar = new Object;
	
	oTempCar.color = sColor;
	
	oTempCar.doors = iDoors;
	
	oTempCar.mpg = iMpg;
	
	oTempCar.showColor = showColor;
	
	return oTempCar;

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2）构造函数方式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在构造函数内部无创建对象，而是使用this关键字。使用new运算符调用构造函数时，在执行第一行代码前先创建一个对象，只有用this才能访问该对象。然后可以直 接赋予this属性，默认情况下是构造函数的返回值（不必明确使用return运算符）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Car(sColor, iDoors, iMpg) {

	this.color = sColor;
	
	this.doors = iDoors;
	
	this.mpg = iMpg;
	
	this.showColor = function() {
	
		alert(this.color);
	
	};

}

var oCar1 = new Car(&amp;quot;red&amp;quot;, 4, 23);

var oCar2 = new Car(&amp;quot;blue&amp;quot;, 3, 25);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3）原型方式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//定义

function Car() {

}

Car.prototype.color = &amp;quot;red&amp;quot;;

Car.prototype.doors = 4;

Car.prototype.drivers = new Array(&amp;quot;Tom&amp;quot;, &amp;quot;Jerry&amp;quot;);

Car.prototype.showColor = function() {

	alert(this.color);

}

//调用：

var car1 = new Car();

var car2 = new Car();

car1.showColor();

car2.showColor();

alert(car1.drivers);

car1.drivers.push(&amp;quot;stephen&amp;quot;);

alert(car1.drivers); //结果：Tom,Jerry,stephen

alert(car2.drivers); //结果：Tom,Jerry,stephen


//可以用json方式简化prototype的定义:

Car.prototype = {

color: &amp;quot;red&amp;quot;,

doors: 4,

drivers: [&amp;quot;Tom&amp;quot;, &amp;quot;Jerry&amp;quot;,&amp;#39;safdad&amp;#39;],

showColor: function() {

	alert(this.color);

}

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4）混合的构造函数/原型方式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性(方法)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//定义

function Car(color,doors) {

	this.color=color;
	
	this.doors=doors;
	
	this.drivers=new Array(&amp;quot;Tom&amp;quot;,&amp;quot;Jerry&amp;quot;);

}

Car.prototype.showColor=function(){

	alert(this.color);

}


//调用：

var car1=new Car(&amp;#39;red&amp;#39;,4);

var car2=new Car(&amp;#39;blue&amp;#39;,4);


car1.showColor();

car2.showColor();


alert(car1.drivers);

car1.drivers.push(&amp;quot;stephen&amp;quot;);

alert(car1.drivers); //结果：Tom,Jerry,stephen

alert(car2.drivers); //结果：Tom,Jerry

alert(car1 instanceof Car);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5）动态原型方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Car() {

	this.color = &amp;quot;red&amp;quot;;
	
	this.doors = 4;
	
	this.drivers = new Array(&amp;quot;Tom&amp;quot;, &amp;quot;Jerry&amp;quot;);
	
	if (typeof Car._initialized == &amp;quot;undefined&amp;quot;) {
	
	Car.prototype.showColor = function() {
	
		alert(this.color);

	}
	
	//…………

}

//最后定义

Car._initialized = true;

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6）混合工厂方式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;目的是创建假构造函数，只返回另一种对象的新实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Car() {
	
	var oTempCar = new Object();
	
	oTempCar.color=&amp;quot;red&amp;quot;;
	
	oTempCar.doors=4;
	
	oTempCar.mpg=23;
	
	oTempCar.showColor = function() {
	
		alert(this.color);
	
	}
	
	return oTempCar;
	
}

//与经典方式不同，这种方式使用new运算符，使它看起来像真正的构造函数：

var oCar = new Car();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于在Car()构造函数内部调用了new运算符，所以将忽略第二个new运算符（位于构造函数之外）。在构造函数内部创建的对象被传递回变量var。这种方式在对象 方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已，还是避免使用这种方式。&lt;/p&gt;

&lt;p&gt;总结：（采用哪种方式)&lt;/p&gt;

&lt;p&gt;目前使用最广泛的是混合的构造函数/原型方式。此外，动态原型方法也很流行，在功能上与构造函数/原型方式等价。可以采用这两种方式中的任何一种。不过不要单独使用经 典的构造函数或原型方式，因为这样会给代码引入问题。&lt;/p&gt;

&lt;h3 id='2_ie_8'&gt;2. 盒模型——外边距、内边距和边框之间的关系，IE 8以下版本的浏览器中的盒模型有什么不同。&lt;/h3&gt;

&lt;h3 id='3css'&gt;3.块级元素与行内元素——怎么用CSS控制它们、它们怎样影响周围的元素以及你觉得应该如何定义它们的样式。&lt;/h3&gt;

&lt;h3 id='4'&gt;4.浮动元素——怎么使用它们、它们有什么问题以及怎么解决这些问题。&lt;/h3&gt;

&lt;h3 id='5htmlxhtml'&gt;5.HTML与XHTML——二者有什么区别，你觉得应该使用哪一个并说出理由。&lt;/h3&gt;

&lt;h3 id='6json'&gt;6.JSON——它是什么、为什么应该使用它、到底该怎么使用它，说出实现细节来。&lt;/h3&gt;

&lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。&lt;/p&gt;

&lt;p&gt;JSON建构于两种结构：&lt;/p&gt;

&lt;p&gt;“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。&lt;/p&gt;

&lt;p&gt;值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。&lt;/p&gt;

&lt;h3 id='7'&gt;7.页面布局：自适应流布局&lt;/h3&gt;

&lt;p&gt;css3盒布局，它允许宽度自适应，改变元素显示顺序，优先加载重要区域。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>伪元素与伪类</title>
   <link href="http://heiniuhaha.github.com/css/2012/07/10/css-double-colon"/>
   <updated>2012-07-10T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/css/2012/07/10/css-double-colon</id>
   <content type="html">&lt;h4 id='css3css3'&gt;单冒号(&lt;code&gt;:&lt;/code&gt;)用于CSS3伪类，双冒号(&lt;code&gt;::&lt;/code&gt;)用于CSS3伪元素。&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;::selection&lt;/code&gt;是CSS3里的伪元素（pseudo-elements）&lt;/p&gt;

&lt;p&gt;一个冒号是伪类，两个冒号是伪元素&lt;/p&gt;

&lt;p&gt;伪类可以独立于文档的元素来分配样式，且可以分配给任何元素，逻辑上和功能上类类似，但是其是预定义的、不存在于文档树中且表达方式也不同，所以叫伪类。&lt;/p&gt;

&lt;p&gt;伪元素所控制的内容和一个元素控制的内容一样，但是伪元素不存在于文档树中，不是真正的元素，所以叫伪元素。&lt;/p&gt;

&lt;p&gt;伪类有：:first-child ，:link:，vistited，:hover:，active:focus，:lang&lt;/p&gt;

&lt;p&gt;伪元素有：:first-line，:first-letter，:before，:after&lt;/p&gt;

&lt;h3 id='id3895'&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href='http://sunflowamedia.com/blog/learn-pseudo-element/'&gt;学习和认识CSS伪元素&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>前端ajax基础点</title>
   <link href="http://heiniuhaha.github.com/ajax/2012/06/10/ajax"/>
   <updated>2012-06-10T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/ajax/2012/06/10/ajax</id>
   <content type="html">&lt;p&gt;一个 JavaScript 对象，即 XMLHttpRequest对象&lt;/p&gt;

&lt;h4 id='xmlhttprequest'&gt;一、XMLHttpRequest的方法和属性。&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;open()：建立到服务器的新请求。&lt;/li&gt;

&lt;li&gt;send()：向服务器发送请求。&lt;/li&gt;

&lt;li&gt;abort()：退出当前请求。&lt;/li&gt;

&lt;li&gt;readyState：提供当前 HTML 的就绪状态。&lt;/li&gt;

&lt;li&gt;responseText：服务器返回的请求响应文本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;备注：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;st.setRequestHeader(&amp;#39;Content-type&amp;#39;, &amp;#39;application/x-www-form-urlencoded&amp;#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;URL编码将 postdata 中不允许使用的字符转换为等效字符实体；URL 解码会反转此编码过程。&lt;/p&gt;

&lt;h4 id='http_requestreadystate'&gt;二、HTTP就绪状态 request.readyState&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;0：请求没有发出（在调用 open() 之前）。&lt;/li&gt;

&lt;li&gt;1：请求已经建立但还没有发出（调用 send() 之前）。&lt;/li&gt;

&lt;li&gt;2：请求已经发出正在处理之中（这里通常可以从响应得到内容头部）。&lt;/li&gt;

&lt;li&gt;3：请求已经处理，响应中通常有部分数据可用，但是服务器还没有完成响应。&lt;/li&gt;

&lt;li&gt;4：响应已完成，可以访问服务器响应并使用它。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id='http_requeststatus'&gt;三、HTTP状态码 request.status&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;200 ： 一切顺利&lt;/li&gt;

&lt;li&gt;404 ： 错误，该页面不存在&lt;/li&gt;

&lt;li&gt;403、401 ： 表示所访问数据受到保护或者禁止访问&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id='ajax'&gt;四、ajax请求方式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;GET方法提交数据不安全，数据置于请求行，客户端地址栏可见; GET 方法提交的数据大小限制在255 个字符之内。&lt;/li&gt;

&lt;li&gt;POST方法提交的数据置于消息主体内，客户端不可见， POST 方法提交的数据大小没有限制。参数不是跟在URL后面的，而是存放在http请求的body部分的，关于请求参数在http请求body中存放的形式类似get方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id='ajax'&gt;五、ajax完整代码&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/*
1、创建新的 XMLHttpRequest 对象，创建一个新变量并赋给它一个 XMLHttpRequest 对象实例
2、打开请求 open()
	- request-type：发送请求的类型。典型的值是 GET 或 POST，但也可以发送 HEAD 请求。
	- url：要连接的 URL。
	- asynch：如果希望使用异步连接则为 true，否则为 false。该参数是可选的，默认为 true。
	- username：如果需要身份验证，则可以在此指定用户名。该可选参数没有默认值。
	- password：如果需要身份验证，则可以在此指定口令。该可选参数没有默认值。	*/

var request = false;
try {
	request = new XMLHttpRequest();
}catch (trymicrosoft) {
	try {
		request = new ActiveXObject(&amp;quot;Msxml2.XMLHTTP&amp;quot;);
	}catch (othermicrosoft) {
		try {
			request = new ActiveXObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;);
		} catch (failed) {
			request = false;
		}  
	}
}
if (!request){
	alert(&amp;quot;Error initializing XMLHttpRequest!&amp;quot;);
}
function getCustomerInfo() {
	var phone = document.getElementById(&amp;quot;phone&amp;quot;).value;
	var url = &amp;quot;/cgi-local/lookupCustomer.php?phone=&amp;quot; + escape(phone);
	request.open(&amp;quot;GET&amp;quot;, url, true);
	request.onreadystatechange = updatePage;
	request.send(null);
}

function updatePage() {
	if (request.readyState == 4) {
		if (request.status == 200) {
			var response = request.responseText.split(&amp;quot;|&amp;quot;);
			document.getElementById(&amp;quot;order&amp;quot;).value = response[0];
			document.getElementById(&amp;quot;address&amp;quot;).innerHTML =
			response[1].replace(/\n/g, &amp;quot;&amp;quot;);
		} else{
			alert(&amp;quot;status is &amp;quot; + request.status);
		}
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='jquery_ajax'&gt;六、jQuery AJAX事件列表&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ajaxStart (Global Event)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This event is broadcast if an Ajax request is started and no other Ajax requests are currently running.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;beforeSend (Local Event)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This event, which is triggered before an Ajax request is started, allows you to modify the XMLHttpRequest object (setting additional headers, if need be.)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ajaxSend (Global Event)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This global event is also triggered before the request is run.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;success (Local Event)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This event is only called if the request was successful (no errors from the server, no errors with the data).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ajaxSuccess (Global Event)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This event is also only called if the request was successful.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;error (Local Event)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This event is only called if an error occurred with the request (you can never have both an error and a success callback with a request).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ajaxError (Global Event)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This global event behaves the same as the local error event.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;complete (Local Event)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This event is called regardless of if the request was successful, or not. You will always receive a complete callback, even for synchronous requests.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ajaxComplete (Global Event)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This event behaves the same as the complete event and will be triggered every time an Ajax request finishes.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ajaxStop (Global Event)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This global event is triggered if there are no more Ajax requests being processed.&lt;/p&gt;

&lt;h4 id='ajax'&gt;七、$.ajax()参数列表&lt;/h4&gt;

&lt;p&gt;参数名 类型 描述&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;url String (默认: 当前页地址) 发送请求的地址。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;type String (默认: &amp;#8220;GET&amp;#8221;) 请求方式 (&amp;#8220;POST&amp;#8221; 或 &amp;#8220;GET&amp;#8221;)， 默认为 &amp;#8220;GET&amp;#8221;。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;timeout Number 设置请求超时时间（毫秒）。此设置将覆盖全局设置。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;async Boolean (默认: true) 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;beforeSend Function 发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function (XMLHttpRequest) {
  this; // the options for this ajax request，this指向ajax请求的选项配置信息
}&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;cache Boolean (默认: true) jQuery 1.2 新功能，设置为 false 将不会从浏览器缓存中加载请求信息。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;complete Function 请求完成后回调函数 (请求成功或失败时均调用)。参数： XMLHttpRequest 对象，成功信息字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function (XMLHttpRequest, textStatus) {
  this; // the options for this ajax request
}&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;contentType String (默认: &amp;#8220;application/x-www-form-urlencoded&amp;#8221;) 发送信息至服务器时内容编码类型。默认值适合大多数应用场合。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;data Object,String 发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:&lt;span&gt;&amp;#8220;bar1&amp;#8221;, &amp;#8220;bar2&amp;#8221;&lt;/span&gt;} 转换为 ’’&amp;amp;foo=bar1&amp;amp;foo=bar2’’。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;dataType String 预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息返回 responseXML 或 responseText，并作为回调函数参数传递，可用值:&lt;/p&gt;

&lt;p&gt;&amp;#8220;xml&amp;#8221;: 返回 XML 文档，可用 jQuery 处理。&lt;/p&gt;

&lt;p&gt;&amp;#8220;html&amp;#8221;: 返回纯文本 HTML 信息；包含 script 元素。&lt;/p&gt;

&lt;p&gt;&amp;#8220;script&amp;#8221;: 返回纯文本 JavaScript 代码。不会自动缓存结果。&lt;/p&gt;

&lt;p&gt;&amp;#8220;json&amp;#8221;: 返回 JSON 数据 。&lt;/p&gt;

&lt;p&gt;&amp;#8220;jsonp&amp;#8221;: JSONP 格式。使用 JSONP 形式调用函数时，如 &amp;#8220;myurl?callback=?&amp;#8221; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;error Function (默认: 自动判断 (xml 或 html)) 请求失败时将调用此方法。这个方法有三个参数：XMLHttpRequest 对象，错误信息，（可能）捕获的错误对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function (XMLHttpRequest, textStatus, errorThrown) {
  // 通常情况下textStatus和errorThown只有其中一个有值 
  this; // the options for this ajax request
}&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;global Boolean (默认: true) 是否触发全局 AJAX 事件。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 。可用于控制不同的Ajax事件&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;ifModified Boolean (默认: false) 仅在服务器数据改变时获取新数据。使用 HTTP 包 Last-Modified 头信息判断。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;processData Boolean (默认: true) 默认情况下，发送的数据将被转换为对象(技术上讲并非字符串) 以配合默认内容类型 &amp;#8220;application/x-www-form-urlencoded&amp;#8221;。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;success Function 请求成功后回调函数。这个方法有两个参数：服务器返回数据，返回状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function (data, textStatus) {
  // data could be xmlDoc, jsonObj, html, text, etc...
  this; // the options for this ajax request
}&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>Jekyll Introduction</title>
   <link href="http://heiniuhaha.github.com/lessons/2011/12/29/jekyll-introduction"/>
   <updated>2011-12-29T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2011/12/29/jekyll-introduction</id>
   <content type="html">&lt;p&gt;This Jekyll introduction will outline specifically what Jekyll is and why you would want to use it. Directly following the intro we&amp;#8217;ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id='overview'&gt;Overview&lt;/h2&gt;

&lt;h3 id='what_is_jekyll'&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &amp;#8220;a simple, blog aware, static site generator&amp;#8221;.&lt;/p&gt;

&lt;h3 id='examples'&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href='https://github.com/mojombo/jekyll/wiki/Sites'&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id='what_does_jekyll_do'&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system. Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files, compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder. The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id='jekyll_is_not_blogging_software'&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements. This is a common source of confusion when getting started. Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id='why_should_i_care'&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient. The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server. Traditional dynamic blogs like Wordpress require a database and server-side code. Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;

&lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;

&lt;li&gt;No internet connection required.&lt;/li&gt;

&lt;li&gt;Ability to publish via git.&lt;/li&gt;

&lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;

&lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;

&lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id='how_jekyll_works'&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples. This information is not intended to specifically teach you how to do anything, rather it is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id='initial_setup'&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href='/index.html#start-now'&gt;installing jekyll&lt;/a&gt; you&amp;#8217;ll need to format your website directory in a way jekyll expects. Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id='the_jekyll_application_base_format'&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 20011-10-25-open-source-is-good.markdown
|   |-- 20011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br /&gt;Stores configuration data.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br /&gt;This folder is for partial views.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt; &lt;br /&gt;This folder is for the main templates your content will be inserted into. You can have different layouts for different pages or page sections.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br /&gt;This folder contains your dynamic content/posts. the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br /&gt;This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br /&gt;This folder is not part of the standard jekyll structure. The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory. Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href='https://github.com/mojombo/jekyll/wiki/Usage'&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id='jekyll_configuration'&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here: &lt;a href='https://github.com/mojombo/jekyll/wiki/Configuration'&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='content_in_jekyll'&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page. These content &amp;#8220;objects&amp;#8221; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id='posts_and_pages'&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax. Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id='working_with_posts'&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt; &lt;br /&gt;Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory. If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file. Additionally, each file must have &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;YAML Front-Matter&lt;/a&gt; prepended to its content. YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br /&gt;Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy. Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; &lt;br /&gt;Posts can have tags associated with them as part of their meta-data. Tags may be placed on posts by providing them in the post&amp;#8217;s YAML front matter. You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt; &lt;br /&gt;Posts may be categorized by providing one or more categories in the YAML front matter. Categories offer more significance over tags in that they can be reflected in the URL path to the given post. Note categories in Jekyll work in a specific way. If you define more than one category you are defining a category hierarchy &amp;#8220;set&amp;#8221;. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy &amp;#8220;lessons/beginner&amp;#8221;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll. You won&amp;#8217;t find &amp;#8220;lessons&amp;#8221; and &amp;#8220;beginner&amp;#8221; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id='working_with_pages'&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br /&gt;Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;In order to register as a Jekyll page the file must contain &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;YAML Front-Matter&lt;/a&gt;. Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br /&gt;Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br /&gt;If pages are defined in sub-directories, the path to the page will be reflected in the url. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br /&gt;You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br /&gt;Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br /&gt;Generating a sitemap is good practice for SEO.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br /&gt;A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='templates_in_jekyll'&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page&amp;#8217;s or post&amp;#8217;s content. All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;. The site variable holds all accessible content and metadata relative to the site. The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br /&gt;Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;Templates should be coded in HTML and contain YAML Front Matter. All templates can contain Liquid code to work with your site&amp;#8217;s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br /&gt;There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;. The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined. Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...

	&amp;lt;body&amp;gt;
	  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
	  &amp;lt;div id=&quot;main&quot;&amp;gt;
	    &amp;#123;{content}&amp;#125;
	  &amp;lt;/div&amp;gt;
	&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id='subtemplates'&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they define another &amp;#8220;root&amp;#8221; layout/template within their YAML Front Matter. This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id='includes'&gt;Includes&lt;/h3&gt;

&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder. Includes are NOT templates, rather they are just code snippets that get included into templates. In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id='using_liquid_for_templating'&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll. This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id='what_is_liquid'&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href='https://github.com/Shopify/liquid'&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href='http://shopify.com'&gt;Shopify&lt;/a&gt;. Liquid is designed for end-users to be able to execute logic within template files without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with your site and post/page data.&lt;/p&gt;

&lt;h3 id='why_do_we_have_to_use_liquid'&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href='http://pages.github.com/'&gt;GitHub Pages&lt;/a&gt;. GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id='liquid_is_not_programmerfriendly'&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code. The point being you can&amp;#8217;t do jackshit in liquid that hasn&amp;#8217;t been allowed explicitly by the implementation. What&amp;#8217;s more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll&amp;#8217;s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins. Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt; &lt;br /&gt;My personal stance is to not invest time trying to hack liquid. It&amp;#8217;s really unnecessary &lt;em&gt;from a programmer&amp;#8217;s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code) you are better off sticking with ruby. Toward that end I&amp;#8217;ve built &lt;a href='http://github.com/plusjade/mustache-with-jekyll'&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='static_assets'&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages. That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2 id='how_jekyll_parses_files'&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt; &lt;br /&gt;This is done with textile or markdown.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt; &lt;br /&gt;This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br /&gt;All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt; &lt;br /&gt;These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax. Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt; &lt;br /&gt;Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id='formatting_files_for_parsing'&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We&amp;#8217;ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;. Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty. This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block. The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here: &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='defining_layouts_for_posts_and_templates_parsing'&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into. If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt; That is to say loading a post file into a template file that refers to another template file with work in the way you&amp;#8217;d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id='how_jekyll_generates_the_final_static_files'&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll&amp;#8217;s job is to generate a static representation of your website. The following is an outline of how that&amp;#8217;s done:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt; &lt;br /&gt;Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt; &lt;br /&gt;Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata. At this stage your site is one big computed ruby object.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br /&gt;Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s). Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &amp;#8220;liquified&amp;#8221;. &lt;br /&gt;&lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt; &lt;br /&gt;Finally the liquid templates are &amp;#8220;rendered&amp;#8221;, thereby processing any liquid syntax provided in the templates and saving the final, static representation of the file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br /&gt;Because Jekyll computes the entire site in one fell swoop, each template is given access to a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you&amp;#8217;ll iterate through and format using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;

&lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap. You can also read the original documentation here: &lt;a href='https://github.com/mojombo/jekyll/wiki/Template-Data'&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='conclusion'&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does. As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id='next_steps'&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at &lt;a href='' /&gt; or jump right into &lt;a href=''&gt;Usage&lt;/a&gt; if you&amp;#8217;d like.&lt;/p&gt;</content>
 </entry>
 
 
</feed>