<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>黑妞haha-前端开发</title>
 <link href="http://heiniuhaha.github.com/atom.xml" rel="self"/>
 <link href="http://heiniuhaha.github.com"/>
 <updated>2012-08-15T11:19:02+08:00</updated>
 <id>http://heiniuhaha.github.com</id>
 <author>
   <name>宋建敏</name>
   <email>heiniuhaha@gmail.com</email>
 </author>

 
 <entry>
   <title>seajs实战参考</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/14/seajs-combat"/>
   <updated>2012-08-14T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/14/seajs-combat</id>
   <content type="html">&lt;h2 id='seajs'&gt;seajs实战参考&lt;/h2&gt;

&lt;p&gt;该页面列举了 SeaJS 中的常用实战过程中的问题。只要掌握这些方法，就可以娴熟地开始对你的网站进行模块化开发了。&lt;/p&gt;

&lt;p&gt;默认情况下，SeaJS 要求所有文件都是标准的 CMD 模块，但现实场景下，有大量 jQuery 插件等非 CMD 模块存在。在 SeaJS 里，通过以下方式，可以直接调用非标准模块。&lt;/p&gt;

&lt;h3 id='js'&gt;全站通用的要加载的库只写一次，而不想每个js里都调用，太繁琐&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//可以放在在 init.js 里暴露到全局，这样，所有在 init.js 之后载入的文件，就都可以直接通过全局变量来拿 $ 等对象。

seajs.use(&amp;#39;init&amp;#39;)

//init.js
define(function(require, exports) {
	var $ = jQuery = require(&amp;#39;jquery&amp;#39;);
	
	// 暴露到全局
	window.$ = $;
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='1__jquery'&gt;1. 暴露 jQuery&lt;/h3&gt;

&lt;p&gt;jQuery 插件都依赖 jQuery 模块，为了加载 jQuery 插件，首先得将 jQuery 模块暴露出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 配置 jquery 并放入预加载项中
seajs.config({
  alias: {
    &amp;#39;jquery&amp;#39;: &amp;#39;https://a.alipayobjects.com/static/arale/jquery/1.7.2/jquery.js&amp;#39;
  },
  preload: [&amp;quot;jquery&amp;quot;]
})

// 将 jQuery 暴露到全局
seajs.modify(&amp;#39;jquery&amp;#39;, function(require, exports) {
  window.jQuery = window.$ = exports
})&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='2__jquery_'&gt;2. 修改 jQuery 插件的接口&lt;/h3&gt;

&lt;p&gt;我们以 jquery.cookie 插件为例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 配置别名
seajs.config({
  alias: {
    &amp;#39;cookie&amp;#39;: &amp;#39;https://raw.github.com/carhartl/jquery-cookie/master/jquery.cookie.js&amp;#39;
  }
})

// 将 jQuery Cookie 插件自动包装成 CMD 接口
seajs.modify(&amp;#39;cookie&amp;#39;, function(require, exports, module) {
  module.exports = $.cookie
})&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='3__cookie_'&gt;3. 调用 Cookie 插件&lt;/h3&gt;

&lt;p&gt;这样，在其他模块中，就可以直接调用 cookie 插件了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a.js:

define(function(require, exports) {
  var cookie = require(&amp;#39;cookie&amp;#39;)

  cookie(&amp;#39;the_cookie&amp;#39;)
  cookie(&amp;#39;the_cookie&amp;#39;, &amp;#39;the_value&amp;#39;)

  // ...
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整范例：&lt;a href='http://seajs.org/test/issues/auto-transport/test.html'&gt;http://seajs.org/test/issues/auto-transport/test.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='seajs'&gt;seajs里版本号和时间戳问题&lt;/h2&gt;

&lt;p&gt;用 seajs 组织项目，上线后，经常需要更新特定文件或所有文件的时间戳，以清空浏览器缓存。最简单的方式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//用来维护 jquery 等类库模块的版本号
seajs.config({
  alias: {
    &amp;#39;jquery&amp;#39;: &amp;#39;jquery/1.6.2/jquery&amp;#39;,
    &amp;#39;backbone&amp;#39;: &amp;#39;backbone/0.5.1/backbone&amp;#39;,
    &amp;#39;a&amp;#39;: &amp;#39;a.js?20110801&amp;#39;,
    &amp;#39;b&amp;#39;: &amp;#39;b.js?20110801&amp;#39;
  }
});	

//利用 map,批量更新时间戳是最方便的
seajs.config({
  &amp;#39;map&amp;#39;: [
    [ /^(.*\.(?:css|js))(.*)$/i, &amp;#39;$1?20110801&amp;#39; ]
  ]
});	&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id424'&gt;条件加载&lt;/h2&gt;

&lt;p&gt;第一种：把依赖的模块都在 define 头部手工声明，不再依赖 SeaJS 的自动解析功能。这个模块同时依赖 play 和 work 两个模块，加载器会把这两个模块文件都下载下来。如果需要在 require 模块之后串行执行代码，那么只能用这个方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&amp;#39;play&amp;#39;, &amp;#39;work&amp;#39;], function(require, exports) {
	 //是出去玩，还是工作？
    var choice = require(condition() ? &amp;#39;play&amp;#39; : &amp;#39;work&amp;#39;);
	//选择的难度
    console.log(choice.hard());
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种：使用 require.async 来进行条件加载，从静态分析的角度来看，require.async适合需要执行动态加载的模块很大（比如大量 json 数据），不适合都下载下来。但是require.async 方式加载的模块，不能打包工具找到，自然也不能被打包进上线的 js 中；而前一种方式可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
    require.async(condition() ? &amp;#39;play&amp;#39; : &amp;#39;work&amp;#39;, function(choice) {
        console.log(choice.hard());
    });
});&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>seajs快速参考</title>
   <link href="http://heiniuhaha.github.com/seajs/2012/08/13/seajs-cheet-sheet"/>
   <updated>2012-08-13T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/seajs/2012/08/13/seajs-cheet-sheet</id>
   <content type="html">&lt;h2 id='seajs'&gt;seajs快速参考&lt;/h2&gt;

&lt;p&gt;该页面列举了 SeaJS 中的常用 API。只要掌握这些方法，就可以娴熟地进行模块化开发。&lt;/p&gt;

&lt;h3 id='id417'&gt;启动模块系统&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;http://modules.seajs.org/seajs/1.2.0/sea.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  	seajs.use(&amp;#39;./main&amp;#39;);
	seajs.use([&amp;#39;./a&amp;#39;, &amp;#39;./b&amp;#39;], function(a, b) {
	  a.init();
	  b.init();
	});	  
&amp;lt;/script&amp;gt;

//callback 参数是可选的。当只启动加载一个模块，且不需要 callback 时，可以用 data-main 属性来简化：
&amp;lt;script src=&amp;quot;http://modules.seajs.org/seajs/1.2.0/sea.js&amp;quot; data-main=&amp;quot;./main&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

/*
引入 sea.js 时，可以把 sea.js 与其他文件打包在一起，提前打包好，或利用 combo 服务动态打包。
无论哪一种方式，为了让 sea.js 内部能快速获取到自身路径，推荐手动加上 id 属性：
加上 seajsnode 值，可以让 sea.js 直接获取到自身路径，而不需要通过其他机制去自动获取。
这对性能和稳定性会有一定提升，推荐默认都加上。
*/
&amp;lt;script src=&amp;quot;path/to/sea.js&amp;quot; id=&amp;quot;seajsnode&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='seajsconfig'&gt;seajs.config&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//seajs.config 可以叠加，可以在多处调用，同名 key 覆盖，不同名的 key 叠加。这样可以做到：区域配置可以覆盖通用配置或可以说在区域配置中可对 seajs config 再做按需配置而不会影响到通用配置。
seajs.config({

  //alias最常用来做版本配置与管理，也可以用来做命名空间管理。
  alias: {
    &amp;#39;es5-safe&amp;#39;: &amp;#39;es5-safe/0.9.2/es5-safe&amp;#39;,
    &amp;#39;json&amp;#39;: &amp;#39;json/1.0.1/json&amp;#39;,
    &amp;#39;jquery&amp;#39;: &amp;#39;jquery/1.7.2/jquery&amp;#39;
  },
  
  /*
  使用 preload 配置项，可以在普通模块加载前，提前加载并初始化好指定模块。
  注意：preload 中的配置，需要等到 use 时才加载。
  preload 配置不能放在模块文件里面
  */
  preload: [
    Function.prototype.bind ? &amp;#39;&amp;#39; : &amp;#39;es5-safe&amp;#39;,
    this.JSON ? &amp;#39;&amp;#39; : &amp;#39;json&amp;#39;
  ],
  
  //值为 true 时，加载器会使用 console.log 输出所有错误和调试信息。 默认为 false, 只输出关键信息
  debug: true,
  
  //该配置可将某个文件映射到另一个。可用于在线调试，非常方便。
  map: [
    [&amp;#39;http://example.com/js/app/&amp;#39;, &amp;#39;http://localhost/js/app/&amp;#39;]
  ],
  
  /*
  SeaJS 在解析顶级标识时，会相对 base 路径来解析。
  注意：一般请不要配置 base 路径，保持默认往往最好最方便。
  base 路径的默认值，与 sea.js 的访问路径相关：
  如果 sea.js 的访问路径是：
    http://example.com/js/libs/sea.js
  则 默认base 路径为：
    http://example.com/js/libs/	 
  */ 
  base: &amp;#39;http://example.com/path/to/base/&amp;#39;,
  
  //获取模块文件时，&amp;lt;script&amp;gt; 或 &amp;lt;link&amp;gt; 标签的 charset 属性。 默认是 utf-8 。
  charset: &amp;#39;utf-8&amp;#39;	  
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='seajsuse'&gt;seajs.use&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
模块加载器
seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里。在模块代码里需要异步加载其他模块时，可以使用 require.async 方法。
*/

seajs.use(&amp;#39;./a&amp;#39;);

seajs.use(&amp;#39;./a&amp;#39;, function(a) {
  a.doSomething();
});

seajs.use([&amp;#39;./a&amp;#39;, &amp;#39;./b&amp;#39;], function(a, b) {
  a.doSomething();
  b.doSomething();
});

//seajs.use 与 dom ready 事件没有任何关系。
//如果某些操作要确保在 dom ready 后执行，需要自己使用 jquery 等类库来保证
seajs.use([&amp;#39;jquery&amp;#39;, &amp;#39;page&amp;#39;], function($, page) {
  $(function() {
    page.init()
  })
})	&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='define'&gt;define&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
CMD 模块定义 define(factory);
define 是全局函数，用来定义模块。
在开发时，define 仅接收一个 factory 参数。
factory 可以是一个函数，也可以是对象、字符串等类型。
factory 为对象、字符串等非函数类型时，表示模块的接口就是该对象、字符串等值。
factory 为函数时，表示模块的构造方法。执行该方法，可以得到模块向外提供的接口。
*/
define(function(require, exports, module) {

  // The module code goes here

});

/*
模块代码需要用 define 回调包起来：id 与 dependencies 参数是可以省略的
id 用来显式指定模块 ID。当你的项目上线，所有的模块都合并到了一个文件中，如果不显示指定， SeaJS 就无从知道哪个模块是哪个了。在开发的时候，一般用不到它。
dependencies 也是如此。它列出了当前模块所依赖的模块，在开发的时候是不需要写明的。 SeaJS 会检查你的模块回调函数，找到所有的 require 语句，从而得到你的模块的所有依赖。 在真正 require 当前模块时，会先去请求这个模块的依赖，加载完毕，再去初始化当前的模块。
*/
define(id, dependencies, function(require, exports, module) {
    // module code.
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='require'&gt;require&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
require 是一个方法，用来获取其他模块提供的接口。
require 接受 模块标识 作为唯一参数

模块依赖解析，靠的是三个重要的规则：
	不能重命名 require
	不能覆盖 require
	require 的参数必须是字符串字面量，不可以 require(foo()) 或者 require(bar)， 也不可以是 require(should_be_a ? &amp;#39;a&amp;#39; : &amp;#39;b&amp;#39;)。	参数值必须是字符串直接量,如 require(&amp;quot;my-module&amp;quot;);
*/
define(function(require) {
  var a = require(&amp;#39;./a&amp;#39;);
  a.doSomething();
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='requireasync'&gt;require.async&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
require.async(id, callback)
async 方法可用来异步加载模块，并在加载完成后执行指定回调。
*/
define(function(require, exports, module) {
  // load one module
  require.async(&amp;#39;./b&amp;#39;, function(b) {
    b.doSomething();
  });

  // load multiple modules
  require.async([&amp;#39;./c&amp;#39;, &amp;#39;./d&amp;#39;], function(c, d) {
    // do something
  });
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='requireresolve'&gt;require.resolve&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
require.resolve(id)
使用模块系统内部的路径解析机制来解析并返回模块路径。该函数不会加载模块，只返回解析后的绝对路径。
*/
define(function(require, exports) {
  console.log(require.resolve(&amp;#39;./b&amp;#39;)); 
  // ==&amp;gt; &amp;#39;http://example.com/js/b.js&amp;#39;
});	&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='exports'&gt;exports&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
exports 是一个对象，用来向外提供模块接口。
exports 仅仅是 module.exports 的一个引用。
在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。
因此给 exports 赋值是无效的，不能用来更改模块接口，正确的写法是用 return 或者给 module.exports 赋值。
exports = {}是错误的，module.exports ={}才是正确的写法。
*/

define(function(require, exports) {
  // snip...
  exports.foo = &amp;#39;bar&amp;#39;;
  exports.doSomething = function() {};
});
module.exports

define(function(require, exports, module) {
  // snip...
  module.exports = {
    name: &amp;#39;a&amp;#39;,
    doSomething: function() {};
  };
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='module'&gt;module&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。
*/
define(function(require, exports, module) {

	//module.id 模块标识。require(module.id) 必然返回此模块的 exports 。
   console.log(require(module.id) === exports); // true
   
   //module.uri根据模块系统的路径解析规则得到的模块绝对路径。
   console.log(module.uri); // http://example.com/path/to/this/file.js
   
   //module.dependencies dependencies 是一个数组，表示当前模块的依赖列表。
   
   /*
   module.exports 当前模块对外提供的接口。
   module.exports 的赋值需要同步执行，不能放在回调函数里
   */
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上接口是最常用的，要牢记于心。&lt;/p&gt;

&lt;h3 id='id418'&gt;可写成如下&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;seajs.config({
  alias: {
    &amp;#39;jquery&amp;#39;: &amp;#39;http://modules.seajs.org/jquery/1.7.2/jquery.js&amp;#39;
  }
});

define(&amp;#39;hi&amp;#39;, function(require, exports) {
    exports.sayHi = function() {
        alert(&amp;#39;hi&amp;#39;)
    } 
})

seajs.use([&amp;#39;jquery&amp;#39;, &amp;#39;hi&amp;#39;], function($, h) {
    $(&amp;#39;#beautiful-sea&amp;#39;).click(h.sayHi)
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='js'&gt;模块化后的js写法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) = {
 
    //原jquery.js代码...
 
    module.exports = $.noConflict(true);
});
 
//init.js
define(function(require, exports, module) = {
    var $ = require(&amp;#39;jquery&amp;#39;);
    var m1 = require(&amp;#39;module1&amp;#39;);
     
    exports.initPage = function() {
        $(&amp;#39;.content&amp;#39;).html(m1.run());    
    }
});
 
//module1.js
define(function(require, exports, module) = {
    var $ = require(&amp;#39;jquery&amp;#39;);
    var m2 = require(&amp;#39;module2&amp;#39;);
    var m3 = require(&amp;#39;module3&amp;#39;);
     
    exports.run = function() {
        return $.merge([&amp;#39;module1&amp;#39;], $.merge(m2.run(), m3.run()));    
    }
});
 
//module2.js
define(function(require, exports, module) = {
    exports.run = function() {
        return [&amp;#39;module2&amp;#39;];
    }
});
 
//module3.js
define(function(require, exports, module) = {
    var $ = require(&amp;#39;jquery&amp;#39;);
    var m4 = require(&amp;#39;module4&amp;#39;);
     
    exports.run = function() {
        return $.merge([&amp;#39;module3&amp;#39;], m4.run());    
    }
});
 
//module4.js
define(function(require, exports, module) = {
    exports.run = function() {
        return [&amp;#39;module4&amp;#39;];
    }
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id419'&gt;实际使用中&lt;/h2&gt;

&lt;p&gt;在工程内使用seajs，以前引用的插件、模块也都要用define的语法重新进行封装，比较麻烦，老代码可以不修改，继续使用就好。但强烈建立花点时间都修改成 CMD 模块，这样对以后的维护，以及页面性能很有好处。不然以后修改起来估计会更麻烦。&lt;/p&gt;

&lt;p&gt;其实可以混用的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;underscore.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;backbone.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script src=&amp;quot;sea.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，常用的 jquery 等类库，依旧是传统的用法，用全局变量引用就好，通过同步引入的方式，也不会有依赖顺序问题。 自己的代码，都按照 CMD 规范写成模块的形式。&lt;/p&gt;

&lt;p&gt;其实上面的方式挺好的，特别对于要兼容老代码的情况的。 推荐还是都彻底模块化，看起来要多写一些 require，但值得，因为这样可以让每个模块自身的信息完整，从而减少对 环境的依赖，对后续的可维护性很好益处。&lt;/p&gt;

&lt;h2 id='seajsapi'&gt;seajs官方api&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href='http://seajs.org/docs/#api'&gt;详细官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='https://github.com/seajs/seajs/issues/240'&gt;模块系统&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='https://github.com/seajs/seajs/issues/242'&gt;CMD 模块定义规范&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='https://github.com/seajs/seajs/issues/258'&gt;模块标识&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='https://github.com/seajs/seajs/issues/259'&gt;require 书写约定&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='https://github.com/seajs/seajs/issues/260'&gt;模块加载器&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='https://github.com/seajs/seajs/issues/262'&gt;配置&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='https://github.com/seajs/seajs/issues/265'&gt;常用插件&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='https://github.com/seajs/seajs/issues/281'&gt;打包部署&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='https://github.com/seajs/seajs/issues/266'&gt;快速参考&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='id420'&gt;第三方库&lt;/h2&gt;

&lt;p&gt;SeaJS 提供了一个类似于npm的管理工具，里面有他们改造好的第三方库，你可以在这里找找是否有适合的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;spm Git Pero: &lt;a href='https://github.com/seajs/spm'&gt;https://github.com/seajs/spm&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;spm module list: &lt;a href='http://seajs.cloudfoundry.com/'&gt;http://seajs.cloudfoundry.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='seajs_blog_'&gt;seajs blog 等文档&lt;/h2&gt;

&lt;h3 id='id421'&gt;初级入门&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://www.cnblogs.com/leoo2sk/archive/2011/06/27/write-javascript-with-seajs.html'&gt;使用 SeaJS 实现模块化 JavaScript 开发&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://clonn.blogspot.com/2011/05/seajs-nonblocking-require-library.html'&gt;SeaJS, 模組化開發加載套件&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.infoq.com/cn/news/2011/05/nodeparty-hangzhou'&gt;NodeParty 杭州站会议纪实：Jscex, SeaJS 与 MyFOX&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/14/seajs-and-nodejs/'&gt;SeaJS – 跨环境模块化开发实践 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://ghsky.com/2011/05/seajs-first-view.html'&gt;初识 SeaJS&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/04/26/intro-to-seajs/'&gt;SeaJS – 不仅仅是脚本加载器 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.infoq.com/cn/presentations/hjp-infoq-salon'&gt;去哪儿网的 JavaScript 模块化之路&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/04/05/seajs-080-released/'&gt;海纳百川、有容乃大 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id422'&gt;中级使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://cyj.me/why-seajs/zh/'&gt;seajs所为何-逸才&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/08/10/extending-built-in-native-objects/'&gt;扩展原生对象与 es5-safe 模块 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/08/01/best-practice-of-version-management/'&gt;SeaJS 里版本号和时间戳管理的最佳实践&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/07/24/online-local-debug/'&gt;在线本地调试大观 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.cnblogs.com/leoo2sk/archive/2011/07/01/temod-intro.html'&gt;在 SeaJS 中实现 html 模板文件的加载（Temod 介绍）&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://blog.163.com/jinlu_hz/blog/static/113830152201142011225195/'&gt;在 SeaJS 里使用 LABjs&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/26/exports-and-module-load-in-seajs/'&gt;SeaJS 中的 exports 和模块加载 -玉伯&lt;/a&gt;-墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/18/jquery-plugins-modulization/'&gt;jQuery 插件的模块化 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/02/seajs-css-support/'&gt;SeaJS – 对 CSS 模块的支持 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/seajs/seajs/issues/286'&gt;直接调用 jQuery 插件等非标准模块的方法&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.heiniuhaha.com/file/sea-zh.js'&gt;seajs中文版源码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id423'&gt;高级探索&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://hax.iteye.com/blog/1146699'&gt;shim是应该抛异常还是应该fail silently？-hax&lt;/a&gt; -墙外&lt;/li&gt;

&lt;li&gt;&lt;a href='http://limu.iteye.com/blog/1136712'&gt;扩展 SeaJS 模块定义中的 module 参数的应用示例 -李牧&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://lifesinger.wordpress.com/2011/05/17/the-difference-between-seajs-and-requirejs/'&gt;SeaJS 和 RequireJS 的异同 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>使用github+jekyll+markdown搭建blog环境，完美替代wordpress</title>
   <link href="http://heiniuhaha.github.com/lessons/2012/08/09/use-jekyll-build-blog"/>
   <updated>2012-08-09T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2012/08/09/use-jekyll-build-blog</id>
   <content type="html">&lt;p&gt;也来讲讲怎么使用github pages做blog环境&lt;/p&gt;

&lt;h2 id='id410'&gt;优点&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;空间免费，github托管，稳定又安全，遭遇过空间商跑路的朋友是不是想起伤心往事；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;允许本地服务器调试，脱离网络写文章毫无压力，因为可以使用git命令同步来管理文章，版本控制妥妥的，对技术人员来说，一键恢复，实在是神物；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;还能绑定顶级域名，亲，人家免费空间竟然还允许我们绑域名有木有~~；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;文章用markedown编写，以前遭受排版困扰的亲们是不是很激动；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id='id411'&gt;购买域名&lt;/h2&gt;

&lt;p&gt;可以去&lt;a href='http://www.net.cn'&gt;万网&lt;/a&gt;，这两天正好在促销. &lt;img alt='net-cn-sales' src='/assets/themes/twitter/pic/net-cn-sales.png' /&gt;&lt;/p&gt;

&lt;h2 id='dnspod'&gt;用免费的dnsPod做域名解析&lt;/h2&gt;

&lt;p&gt;dnspod链接地址&lt;a href='https://www.dnspod.cn/'&gt;https://www.dnspod.cn/&lt;/a&gt; &lt;img alt='dnspod settings' src='/assets/themes/twitter/pic/dnspod-setting.png' /&gt;&lt;/p&gt;

&lt;h2 id='githubjekyll'&gt;github注册和本地电脑jekyll等环境配置&lt;/h2&gt;

&lt;p&gt;参考最底下的参考文章，省略。。。&lt;/p&gt;

&lt;h2 id='id412'&gt;命令&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;h3 id='git'&gt;git命令获取远程文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='id413'&gt;定位到目录&lt;code&gt;heiniu.github.com&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd .ssh/heiniuhaha.github.com&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='id414'&gt;使用&lt;code&gt;rake&lt;/code&gt;命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;rake page           # Create a new page.
rake post           # Begin a new post in ./_posts
rake preview        # Launch preview environment&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='markdown'&gt;写文章的时候学习下&lt;a href='https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md'&gt;markdown语法&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;如:中文单引号 &amp;#96; 用来标注小块代码,如&lt;code&gt;github&lt;/code&gt; &lt;code&gt;jekyll&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;h3 id='git'&gt;最后提交git代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git add .
git commit . -m &amp;#39;just another commit&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='id415'&gt;日常发布完整命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git//本地如果无远程代码，先做这步，不然就忽略
cd .ssh/heiniuhaha.github.com//定位到你blog的目录下
git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件
git status //查看本地自己修改了多少文件
git add .//添加远程不存在的git文件
git commit * -m &amp;quot;what I want told to someone&amp;quot;
git push origin master //更新到远程服务器上&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id416'&gt;参考文章&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://beiyuu.com/github-pages/'&gt;使用Github Pages建独立博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://blog.leezhong.com/tech/2010/08/25/make-github-as-blog-engine.html'&gt;使用github作为博客引擎&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://jekyllbootstrap.com/'&gt;The Quickest Way to Blog with Jekyll.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='git_api_'&gt;附件：git api 总结图&lt;/h2&gt;

&lt;p&gt;链接：&lt;a href='/assets/themes/twitter/pic/git-api.png'&gt;http://www.heiniuhaha.com/assets/themes/twitter/pic/git-api.png&lt;/a&gt; &lt;img alt='git api 总结图' src='/assets/themes/twitter/pic/git-api.png' /&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Use Google Code Prettify</title>
   <link href="http://heiniuhaha.github.com/lessons/2012/08/09/use-google-code-prettify"/>
   <updated>2012-08-09T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2012/08/09/use-google-code-prettify</id>
   <content type="html">&lt;h2 id='jekyll_googlecodeprettify'&gt;jekyll中代码高亮 google-code-prettify&lt;/h2&gt;

&lt;p&gt;看了jekyll的代码高亮插件pygments,觉得配置太复杂,就用了轻量级的google-code-prettify,使用非常方便.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先下载用于高亮代码的文件包,点击&lt;a href='http://code.google.com/p/google-code-prettify/downloads/list'&gt;google-code-prettify下载地址&lt;/a&gt;下载small版本的代码.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;复制进相应的目录,找到default.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Users/heiniu/.ssh/heiniuhaha.github.com/_includes/themes/default.html&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;打开default.html,在最后面添加相应的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/code/prettify.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/jquery-1.8.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  $(function(){
    $(&amp;quot;pre&amp;quot;).addClass(&amp;quot;prettyprint linenums&amp;quot;);
    prettyPrint();
    $(&amp;#39;.entry a&amp;#39;).each(function(){
      if($(this).attr(&amp;quot;href&amp;quot;).indexOf(&amp;quot;heiniuhaha&amp;quot;) == -1){
        $(this).attr(&amp;quot;target&amp;quot;, &amp;quot;_blank&amp;quot;);
      }
    })
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>My Github First Blog</title>
   <link href="http://heiniuhaha.github.com/lessons/2012/08/07/my-github-first-blog"/>
   <updated>2012-08-07T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2012/08/07/my-github-first-blog</id>
   <content type="html">&lt;h2 id='themes'&gt;应用themes发现的问题&lt;/h2&gt;

&lt;p&gt;我尝试了the-program的theme,但是出现一个使用iframe的警告,看了源文件,没有发现可修复的地方,直接放弃这个theme吧.&lt;/p&gt;

&lt;p&gt;&lt;img alt='theme iframe waring' src='/assets/themes/twitter/img/theme-iframe.png' /&gt;&lt;/p&gt;

&lt;h4 id='code'&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;For security reasons,framing is not allowed.
	
&amp;lt;iframe src=&amp;quot;http://markdotto.github.com/github-buttons/github-btn.html?user=plusjade&amp;amp;repo=jekyll-bootstrap&amp;amp;type=fork&amp;amp;count=true&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我只能换成twitter皮肤,我想这个皮肤应该是最稳定的了.等使用熟练后再改成自己的皮肤.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>前端技术牛人列表</title>
   <link href="http://heiniuhaha.github.com/f2e/2012/07/30/f2e-master"/>
   <updated>2012-07-30T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/f2e/2012/07/30/f2e-master</id>
   <content type="html">&lt;h2 id='id408'&gt;牛人列表&lt;/h2&gt;

&lt;p&gt;该页面列举了我仰慕的前端牛人，以他们为榜样，站在巨人的肩膀上学习，能让我们再前端开发道路上更顺利。也推荐给大家学习的目标。会持续更新&amp;#8230;&lt;/p&gt;

&lt;h3 id='id409'&gt;前端架构&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href='http://hikejun.com/blog/'&gt;张克军-kejun&lt;/a&gt;&lt;/strong&gt; 绝对大牛级别的人物，目前在豆瓣负责前端架构，经常出现在各种技术交流活动中，如咱熟知的D2&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href='http://lifesinger.wordpress.com/'&gt;玉伯-岁月如歌&lt;/a&gt;&lt;/strong&gt; 如今火热的Web 浏览器端的模块加载器seajs的开发者，目前在支付宝，研究型+实战型牛人，经常出现在各种技术交流活动中，如咱熟知的D2，乐于布道。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Jekyll Introduction</title>
   <link href="http://heiniuhaha.github.com/lessons/2011/12/29/jekyll-introduction"/>
   <updated>2011-12-29T00:00:00+08:00</updated>
   <id>http://heiniuhaha.github.com/lessons/2011/12/29/jekyll-introduction</id>
   <content type="html">&lt;p&gt;This Jekyll introduction will outline specifically what Jekyll is and why you would want to use it. Directly following the intro we&amp;#8217;ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id='overview'&gt;Overview&lt;/h2&gt;

&lt;h3 id='what_is_jekyll'&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &amp;#8220;a simple, blog aware, static site generator&amp;#8221;.&lt;/p&gt;

&lt;h3 id='examples'&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href='https://github.com/mojombo/jekyll/wiki/Sites'&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id='what_does_jekyll_do'&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system. Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files, compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder. The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id='jekyll_is_not_blogging_software'&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements. This is a common source of confusion when getting started. Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id='why_should_i_care'&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient. The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server. Traditional dynamic blogs like Wordpress require a database and server-side code. Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;

&lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;

&lt;li&gt;No internet connection required.&lt;/li&gt;

&lt;li&gt;Ability to publish via git.&lt;/li&gt;

&lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;

&lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;

&lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id='how_jekyll_works'&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples. This information is not intended to specifically teach you how to do anything, rather it is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id='initial_setup'&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href='/index.html#start-now'&gt;installing jekyll&lt;/a&gt; you&amp;#8217;ll need to format your website directory in a way jekyll expects. Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id='the_jekyll_application_base_format'&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 20011-10-25-open-source-is-good.markdown
|   |-- 20011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br /&gt;Stores configuration data.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br /&gt;This folder is for partial views.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt; &lt;br /&gt;This folder is for the main templates your content will be inserted into. You can have different layouts for different pages or page sections.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br /&gt;This folder contains your dynamic content/posts. the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br /&gt;This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br /&gt;This folder is not part of the standard jekyll structure. The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory. Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href='https://github.com/mojombo/jekyll/wiki/Usage'&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id='jekyll_configuration'&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here: &lt;a href='https://github.com/mojombo/jekyll/wiki/Configuration'&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='content_in_jekyll'&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page. These content &amp;#8220;objects&amp;#8221; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id='posts_and_pages'&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax. Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id='working_with_posts'&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt; &lt;br /&gt;Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory. If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file. Additionally, each file must have &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;YAML Front-Matter&lt;/a&gt; prepended to its content. YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br /&gt;Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy. Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; &lt;br /&gt;Posts can have tags associated with them as part of their meta-data. Tags may be placed on posts by providing them in the post&amp;#8217;s YAML front matter. You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt; &lt;br /&gt;Posts may be categorized by providing one or more categories in the YAML front matter. Categories offer more significance over tags in that they can be reflected in the URL path to the given post. Note categories in Jekyll work in a specific way. If you define more than one category you are defining a category hierarchy &amp;#8220;set&amp;#8221;. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy &amp;#8220;lessons/beginner&amp;#8221;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll. You won&amp;#8217;t find &amp;#8220;lessons&amp;#8221; and &amp;#8220;beginner&amp;#8221; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id='working_with_pages'&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br /&gt;Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;In order to register as a Jekyll page the file must contain &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;YAML Front-Matter&lt;/a&gt;. Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br /&gt;Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br /&gt;If pages are defined in sub-directories, the path to the page will be reflected in the url. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br /&gt;You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br /&gt;Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br /&gt;Generating a sitemap is good practice for SEO.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br /&gt;A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='templates_in_jekyll'&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page&amp;#8217;s or post&amp;#8217;s content. All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;. The site variable holds all accessible content and metadata relative to the site. The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br /&gt;Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;Templates should be coded in HTML and contain YAML Front Matter. All templates can contain Liquid code to work with your site&amp;#8217;s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br /&gt;There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;. The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined. Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id='subtemplates'&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they define another &amp;#8220;root&amp;#8221; layout/template within their YAML Front Matter. This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id='includes'&gt;Includes&lt;/h3&gt;

&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder. Includes are NOT templates, rather they are just code snippets that get included into templates. In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id='using_liquid_for_templating'&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll. This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id='what_is_liquid'&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href='https://github.com/Shopify/liquid'&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href='http://shopify.com'&gt;Shopify&lt;/a&gt;. Liquid is designed for end-users to be able to execute logic within template files without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with your site and post/page data.&lt;/p&gt;

&lt;h3 id='why_do_we_have_to_use_liquid'&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href='http://pages.github.com/'&gt;GitHub Pages&lt;/a&gt;. GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id='liquid_is_not_programmerfriendly'&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code. The point being you can&amp;#8217;t do jackshit in liquid that hasn&amp;#8217;t been allowed explicitly by the implementation. What&amp;#8217;s more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll&amp;#8217;s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins. Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt; &lt;br /&gt;My personal stance is to not invest time trying to hack liquid. It&amp;#8217;s really unnecessary &lt;em&gt;from a programmer&amp;#8217;s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code) you are better off sticking with ruby. Toward that end I&amp;#8217;ve built &lt;a href='http://github.com/plusjade/mustache-with-jekyll'&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='static_assets'&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages. That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2 id='how_jekyll_parses_files'&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt; &lt;br /&gt;This is done with textile or markdown.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt; &lt;br /&gt;This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br /&gt;All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt; &lt;br /&gt;These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax. Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt; &lt;br /&gt;Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id='formatting_files_for_parsing'&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We&amp;#8217;ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;. Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty. This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block. The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here: &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='defining_layouts_for_posts_and_templates_parsing'&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into. If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt; That is to say loading a post file into a template file that refers to another template file with work in the way you&amp;#8217;d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id='how_jekyll_generates_the_final_static_files'&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll&amp;#8217;s job is to generate a static representation of your website. The following is an outline of how that&amp;#8217;s done:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt; &lt;br /&gt;Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt; &lt;br /&gt;Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata. At this stage your site is one big computed ruby object.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br /&gt;Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s). Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &amp;#8220;liquified&amp;#8221;. &lt;br /&gt;&lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt; &lt;br /&gt;Finally the liquid templates are &amp;#8220;rendered&amp;#8221;, thereby processing any liquid syntax provided in the templates and saving the final, static representation of the file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br /&gt;Because Jekyll computes the entire site in one fell swoop, each template is given access to a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you&amp;#8217;ll iterate through and format using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;

&lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap. You can also read the original documentation here: &lt;a href='https://github.com/mojombo/jekyll/wiki/Template-Data'&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='conclusion'&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does. As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id='next_steps'&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at &lt;a href='' /&gt; or jump right into &lt;a href=''&gt;Usage&lt;/a&gt; if you&amp;#8217;d like.&lt;/p&gt;</content>
 </entry>
 
 
</feed>